name: Platform Linting and Tests

on:
  workflow_call:
    inputs:
      should-skip-running-and-always-succeed:
        description: "Whether to force the checks to succeed"
        required: false
        type: boolean
    secrets:
      TURBOREPO_REMOTE_CACHING_TOKEN:
        required: true
      TURBOREPO_REMOTE_CACHING_TEAM:
        required: true
      DOCKER_USERNAME:
        required: true
      DOCKER_PASSWORD:
        required: true

jobs:
  paths-filter:
    name: Detect changed paths
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      mcp-server-base-image: ${{ steps.filter.outputs.mcp-server-base-image }}
    steps:
      - name: Checkout repository
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false

      - name: Filter paths
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        id: filter
        uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36 # v3.0.2
        with:
          filters: |
            mcp-server-base-image:
              - 'platform/mcp_server_docker_image/**'
              - '.github/workflows/build-base-mcp-server-docker-image.yml'

  platform-linting-and-tests:
    name: Platform Linting and Tests
    runs-on: blacksmith-8vcpu-ubuntu-2404
    permissions:
      contents: read
    defaults:
      run:
        working-directory: ./platform
    env:
      TURBO_TOKEN: ${{ secrets.TURBOREPO_REMOTE_CACHING_TOKEN }}
      TURBO_TEAM: ${{ secrets.TURBOREPO_REMOTE_CACHING_TEAM }}
    steps:
      - name: Checkout project
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false

      - name: Setup environment
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        uses: ./.github/actions/setup-env
        continue-on-error: ${{ inputs.should-skip-running-and-always-succeed }}
        with:
          working-directory: ./platform

      - name: Setup environment variables
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        run: cp .env.example .env

      - name: Type checking, linting, formatting checks
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        run: pnpm check:ci

  platform-e2e-tests:
    name: Platform e2e Tests
    runs-on: blacksmith-16vcpu-ubuntu-2404
    permissions:
      contents: read
    steps:
      - name: Checkout repository
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false

      - name: Setup environment
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        uses: ./.github/actions/setup-env
        with:
          working-directory: ./platform

      - name: Setup environment variables
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        working-directory: ./platform
        run: cp .env.example .env

      - name: Setup Archestra Platform
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        uses: ./.github/actions/setup-archestra-platform
        with:
          kind-config-path: .github/kind.yaml
          kind-cluster-name: archestra-ci-cluster
          helm-values-path: .github/values-ci.yaml
          deploy-e2e-dependencies: "true"
          build-platform-image: "true"
          platform-image-tag: archestra/platform:ci-test
          platform-context: ./platform
          turbo-team: ${{ secrets.TURBOREPO_REMOTE_CACHING_TEAM }}
          turbo-token: ${{ secrets.TURBOREPO_REMOTE_CACHING_TOKEN }}

      # Check migration consistency using drizzle-kit check
      # https://orm.drizzle.team/docs/drizzle-kit-check
      # The drizzle-kit check command lets you check consistency of your generated SQL migrations history
      - name: Check drizzle-kit migrations consistency
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        working-directory: ./platform/backend
        run: pnpm drizzle-kit check

      - name: Check for codegen'd changes
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        working-directory: ./platform
        run: |
          pnpm codegen:api-client
          # Ensure generated files are properly formatted and linted
          pnpm lint:fix

          # Check both unstaged and staged changes
          if ! git diff --exit-code || ! git diff --cached --exit-code; then
            echo "::error::Generated code is not up to date. Please run 'pnpm codegen:api-client && pnpm lint:fix' locally and commit the changes."
            exit 1
          else
            echo "Generated code is up to date"
            echo "codegen-changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Verify no pending database migrations
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        id: db-migration-check
        working-directory: ./platform
        run: |
          # Run db generate with timeout to prevent hanging on interactive prompts
          set +e  # Don't exit on command failure

          echo "Running pnpm db:generate -- awaiting up to 15 seconds for a potential drizzle-kit generate interactive prompt (which could indicate a pending database migration, such as a table rename)"

          # Use timeout and expect no interaction - if it hangs, it means there's a pending migration which requires
          # user input to continue
          if timeout 15s pnpm db:generate > /tmp/db_generate_output.txt 2>&1; then
            # Command completed successfully within timeout
            output=$(cat /tmp/db_generate_output.txt)
            echo "Output from pnpm db:generate:"
            echo "$output"

            # Check if there's an interactive prompt in the output (shouldn't happen if it completed)
            if echo "$output" | grep -q "❯\|Is.*table created or renamed"; then
              echo "❌ Interactive prompt detected - there are pending database migrations that need to be committed"
              echo "Run 'pnpm db:generate' locally, make your choices, and commit the resulting migration files"
              exit 1
            fi
          else
            # Command timed out or failed
            exit_code=$?
            output=$(cat /tmp/db_generate_output.txt 2>/dev/null || echo "No output captured")

            echo "Output from pnpm db:generate (before timeout/failure):"
            echo "$output"

            if [ $exit_code -eq 124 ]; then
              # Timeout occurred - likely waiting for interactive input
              echo "❌ Command timed out - likely waiting for interactive input about pending database migrations"
              echo "Run 'pnpm db:generate' locally, make your choices, and commit the resulting migration files"
            else
              echo "❌ pnpm db:generate failed with exit code $exit_code"
            fi
            exit 1
          fi

          set -e  # Re-enable exit on error

          # Check both unstaged and staged changes
          # If db:generate produced new migration files, it means the PR is missing migrations
          if ! git diff --exit-code || ! git diff --cached --exit-code; then
            echo "::error::Database schema has changed but migrations are missing. Please run 'pnpm db:generate' locally and commit the resulting migration files."
            git diff --name-only
            git diff --cached --name-only
            exit 1
          else
            echo "✅ No new migration files were generated - schema is in sync with migrations"
          fi

      # Resolve Playwright version for the container used to run e2e tests
      - name: Resolve Playwright version
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        run: |
          VERSION=$(cat platform/e2e-tests/package.json | jq -r '.devDependencies["@playwright/test"]' | sed 's/^[\^~]//')
          echo "Resolved Playwright version: $VERSION"
          echo "PLAYWRIGHT_VERSION=$VERSION" >> $GITHUB_ENV

      # Run E2E tests inside the official Playwright container
      # This eliminates the need for manual Playwright browser installation and caching
      # See https://github.com/microsoft/playwright/issues/7249#issuecomment-3345742301
      - name: Run E2E tests
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        working-directory: ./platform
        run: |
          docker run --rm \
            --network host \
            --ipc=host \
            -v "$GITHUB_WORKSPACE:/work" \
            -w /work/platform \
            -e CI=true \
            -e PLAYWRIGHT_BROWSERS_PATH=/ms-playwright \
            "mcr.microsoft.com/playwright:v${PLAYWRIGHT_VERSION}-noble" \
            /bin/bash -c "corepack enable && corepack prepare pnpm@10.24.0 --activate && pnpm test:e2e"

      - name: Upload Playwright report
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: platform/e2e-tests/playwright-report/
          retention-days: 30

      - name: Show logs on failure
        if: failure()
        run: |
          echo "=== Kubernetes Pods ==="
          kubectl get pods -o wide

          echo "=== Kubernetes Services ==="
          kubectl get services

          echo "=== Archestra Platform Logs ==="
          kubectl logs -l app.kubernetes.io/name=archestra-platform --tail=200

          echo "=== PostgreSQL Logs ==="
          kubectl logs -l app.kubernetes.io/name=postgresql --tail=200

          echo "=== WireMock Logs ==="
          kubectl logs -l app=e2e-tests-wiremock --tail=200

          echo "=== Keycloak Logs ==="
          kubectl logs -l app.kubernetes.io/name=keycloak --tail=200

          echo "=== Describe Archestra Platform Pod ==="
          kubectl describe pod -l app.kubernetes.io/name=archestra-platform

          echo "=== Describe PostgreSQL Pod ==="
          kubectl describe pod -l app.kubernetes.io/name=postgresql

  platform-docker-image-scanning:
    name: Platform Docker Image Scanning
    runs-on: blacksmith-16vcpu-ubuntu-2404
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout repository
        if: ${{ github.event_name == 'pull_request' && inputs.should-skip-running-and-always-succeed != true }}
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: true

      - name: Build Docker image
        if: ${{ github.event_name == 'pull_request' && inputs.should-skip-running-and-always-succeed != true }}
        uses: ./.github/actions/build-platform-docker-image
        with:
          context: ./platform
          load: "true"
          tags: archestra/platform:ci-test
          turbo-team: ${{ secrets.TURBOREPO_REMOTE_CACHING_TEAM }}
          turbo-token: ${{ secrets.TURBOREPO_REMOTE_CACHING_TOKEN }}

      # Run docker scout to check for vulnerabilities and recommendations
      # https://github.com/docker/scout-action
      #
      # Branch ruleset has been configured to block PRs with critical or high vulnerabilities.
      # https://docs.github.com/en/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#pull-request-check-failures-for-code-scanning-alerts
      #
      # NOTE: This step is skipped for PRs from forks because GitHub doesn't expose
      # repository secrets to workflows triggered by fork PRs (for security reasons).
      # Docker Scout requires Docker Hub authentication to run.
      - name: Docker Scout
        if: ${{ github.event_name == 'pull_request' && inputs.should-skip-running-and-always-succeed != true && github.event.pull_request.head.repo.fork != true }}
        uses: docker/scout-action@f8c776824083494ab0d56b8105ba2ca85c86e4de # v1.18.2
        with:
          command: cves,recommendations,compare
          image: archestra/platform:ci-test
          to: docker.io/archestra/platform:latest
          dockerhub-user: ${{ secrets.DOCKER_USERNAME }}
          dockerhub-password: ${{ secrets.DOCKER_PASSWORD }}
          ignore-unchanged: true
          only-severities: critical,high
          write-comment: true
          github-token: ${{ secrets.GITHUB_TOKEN }} # to be able to write the comment
          sarif-file: sarif.output.json

      # Upload SARIF result to GitHub Code Scanning
      # https://github.com/docker/scout-action?tab=readme-ov-file#analyze-vulnerabilities-and-upload-report-to-github-code-scanning
      #
      # NOTE: Skipped for fork PRs since Docker Scout step is skipped (no SARIF file generated).
      - name: Upload SARIF result
        if: ${{ github.event_name == 'pull_request' && inputs.should-skip-running-and-always-succeed != true && github.event.pull_request.head.repo.fork != true }}
        uses: github/codeql-action/upload-sarif@4e94bd11f71e507f7f87df81788dff88d1dacbfb # v4.31.0
        with:
          sarif_file: sarif.output.json

  helm-chart-linting-and-tests:
    name: Helm Chart Linting and Tests
    runs-on: blacksmith-4vcpu-ubuntu-2404
    permissions:
      contents: read
    defaults:
      run:
        working-directory: ./platform/helm/archestra
    steps:
      - name: Checkout project
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false

      - name: Linting
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        run: helm lint .

      - name: Tests
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        run: |
          helm plugin install https://github.com/helm-unittest/helm-unittest.git
          helm unittest .

      - name: helm package
        if: ${{ inputs.should-skip-running-and-always-succeed != true }}
        # NOTE: can't use ${{ github.sha }} for version here because it's not a valid version number
        # and helm package explicitly checks this
        run: |
          helm package . --version v0.0.1 --app-version v0.0.1

  # Test that the MCP server base Docker image builds successfully
  # Only runs when relevant files are changed
  mcp-server-base-image-build:
    name: MCP Server Base Image Build
    needs: paths-filter
    if: ${{ needs.paths-filter.outputs.mcp-server-base-image == 'true' }}
    permissions:
      contents: read
      id-token: write # Required for Workload Identity Federation
    uses: ./.github/workflows/build-base-mcp-server-docker-image.yml
    with:
      push_to_gcr: false
      version: test
