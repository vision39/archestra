// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'http://localhost:9000' | (string & {});
};

export type SupportedProvidersInput = 'openai' | 'gemini' | 'anthropic';

export type SupportedProvidersDiscriminatorInput = 'openai:chatCompletions' | 'gemini:generateContent' | 'anthropic:messages';

export type OpenAiChatCompletionRequestInput = {
    model: string;
    /**
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1186
     */
    messages: Array<{
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'developer';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'system';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L765
             */
            image_url: {
                url: string;
                detail: 'auto' | 'low' | 'high';
            };
        } | {
            type: 'input_audio';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L792
             */
            input_audio: {
                data: string;
                format: 'wav' | 'mp3';
            };
        } | {
            type: 'file';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L732
             */
            file: {
                file_data?: string;
                file_id?: string;
                filename?: string;
            };
        }>;
        role: 'user';
        name?: string;
    } | {
        role: 'assistant';
        audio?: {
            id: string;
        } | unknown;
        content?: string | Array<{
            type: 'text';
            text: string;
        }> | Array<{
            type: 'refusal';
            refusal: string;
        }> | unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L431
         */
        function_call?: {
            arguments: string;
            name: string;
        } | unknown;
        name?: string;
        refusal?: string | unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1197
         */
        tool_calls?: Array<{
            id: string;
            type: 'function';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
             */
            function: {
                arguments: string;
                name: string;
            };
        } | {
            id: string;
            type: 'custom';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
             */
            custom: {
                input: string;
                name: string;
            };
        }>;
    } | {
        role: 'tool';
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        tool_call_id: string;
    } | {
        role: 'function';
        content: string | unknown;
        name: string;
    }>;
    /**
     *
     * A function tool that can be used to generate a response.
     *
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1392
     *
     */
    tools?: Array<{
        type: 'function';
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L174
         */
        function: {
            name: string;
            description?: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            strict?: boolean | unknown;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool, used to identify it in tool calls
             */
            name: string;
            /**
             * Optional description of the custom tool, used to provide more context
             */
            description?: string;
            /**
             * The input format for the custom tool. Default is unconstrained text.
             */
            format?: {
                /**
                 * Unconstrained text format. Always `text`
                 */
                type: 'text';
            } | {
                type: 'grammar';
                /**
                 * Your chosen grammar
                 */
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar definition
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    }>;
    /**
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1405
     */
    tool_choice?: 'none' | 'auto' | 'required' | {
        type: 'allowed_tools';
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1455
         */
        allowed_tools: {
            /**
             *
             * Constrains the tools available to the model to a pre-defined set.
             *
             * auto allows the model to pick from among the allowed tools and generate a
             * message.
             *
             * required requires the model to call one or more of the allowed tools.
             *
             */
            mode: 'auto' | 'required';
            /**
             * A list of tool definitions that the model should be allowed to call
             */
            tools: Array<{
                [key: string]: {
                    type: 'function';
                    /**
                     * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L174
                     */
                    function: {
                        name: string;
                        description?: string;
                        /**
                         *
                         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
                         *
                         * The parameters the functions accepts, described as a JSON Schema object. See the
                         * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
                         * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
                         * documentation about the format.
                         *
                         * Omitting parameters defines a function with an empty parameter list.
                         *
                         */
                        parameters?: {
                            [key: string]: unknown;
                        };
                        strict?: boolean | unknown;
                    };
                };
            }>;
        };
    } | {
        type: 'function';
        function: {
            name: string;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool, used to identify it in tool calls
             */
            name: string;
            /**
             * Optional description of the custom tool, used to provide more context
             */
            description?: string;
            /**
             * The input format for the custom tool. Default is unconstrained text.
             */
            format?: {
                /**
                 * Unconstrained text format. Always `text`
                 */
                type: 'text';
            } | {
                type: 'grammar';
                /**
                 * Your chosen grammar
                 */
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar definition
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    };
    temperature?: number | unknown;
    max_tokens?: number | unknown;
    stream?: boolean | unknown;
};

export type OpenAiChatCompletionResponseInput = {
    id: string;
    choices: Array<{
        finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
        index: number;
        logprobs: unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1000
         */
        message: {
            content: string | unknown;
            refusal: string | unknown;
            role: 'assistant';
            annotations?: Array<unknown>;
            audio?: unknown;
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L431
             */
            function_call?: {
                arguments: string;
                name: string;
            } | unknown;
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1197
             */
            tool_calls?: Array<{
                id: string;
                type: 'function';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
                 */
                function: {
                    arguments: string;
                    name: string;
                };
            } | {
                id: string;
                type: 'custom';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
                 */
                custom: {
                    input: string;
                    name: string;
                };
            }>;
        };
    }>;
    created: number;
    model: string;
    object: 'chat.completion';
    server_tier?: string;
    system_fingerprint?: string | unknown;
    /**
     * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L113
     */
    usage?: {
        completion_tokens: number;
        prompt_tokens: number;
        total_tokens: number;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L144
         */
        completion_tokens_details?: unknown;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L173
         */
        prompt_tokens_details?: unknown;
    };
};

export type GeminiGenerateContentRequestInput = {
    /**
     * The content of the current conversation with the model. For single-turn queries, this is a single instance. For multi-turn queries like chat, this is a repeated field that contains the conversation history and the latest request
     */
    contents: Array<{
        role: 'user' | 'model' | 'function';
        parts: Array<{
            /**
             * Indicates if the part is thought from the model
             */
            thought?: boolean;
            /**
             * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
             */
            thoughtSignature?: string;
            /**
             * https://ai.google.dev/api/caching#Part
             */
            data: {
                text: string;
            } | {
                inlineData: {
                    /**
                     * The IANA standard MIME type of the source data. Examples: - image/png - image/jpeg If an unsupported MIME type is provided, an error will be returned
                     */
                    mimeType: string;
                    /**
                     * Raw bytes for media formats. Base64 encoded
                     */
                    data: string;
                };
            } | {
                functionCall: {
                    /**
                     * Optional. The unique id of the function call. If populated, the client to execute the functionCall and return the response with the matching id.
                     */
                    id?: string;
                    name: string;
                    /**
                     * The function parameters and values in JSON object format.
                     */
                    args?: {
                        [key: string]: unknown;
                    };
                };
            } | {
                functionResponse: {
                    /**
                     * The id of the function call this response is for. Populated by the client to match the corresponding function call id
                     */
                    id?: string;
                    /**
                     * The name of the function to call. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
                     */
                    name: string;
                    /**
                     * The function response in JSON object format.
                     */
                    response: {
                        [key: string]: unknown;
                    };
                    /**
                     * Signals that function call continues, and more responses will be returned, turning the function call into a generator. Is only applicable to NON_BLOCKING function calls, is ignored otherwise. If set to false, future responses will not be considered. It is allowed to return empty response with willContinue=False to signal that the function call is finished. This may still trigger the model generation. To avoid triggering the generation and finish the function call, additionally set scheduling to SILENT
                     */
                    willContinue?: boolean;
                    /**
                     *
                     * Specifies how the response should be scheduled in the conversation. Only applicable to NON_BLOCKING function calls, is ignored otherwise. Defaults to WHEN_IDLE.
                     *
                     * https://ai.google.dev/api/caching#Scheduling
                     *
                     */
                    scheduling?: 'SCHEDULING_UNSPECIFIED' | 'SILENT' | 'WHEN_IDLE' | 'INTERRUPT';
                };
            } | {
                fileData: {
                    /**
                     * The IANA standard MIME type of the source data
                     */
                    mimeType?: string;
                    /**
                     * URI
                     */
                    fileUri: string;
                };
            } | {
                /**
                 *
                 * Programming language of the code
                 *
                 * https://ai.google.dev/api/caching#Language
                 *
                 */
                language: 'LANGUAGE_UNSPECIFIED' | 'PYTHON';
                executableCode: {
                    /**
                     * The code to be executed
                     */
                    code: string;
                };
            } | {
                codeExecutionResult: {
                    /**
                     *
                     * Outcome of the code execution.
                     *
                     * https://ai.google.dev/api/caching#Outcome
                     *
                     */
                    outcome: 'OUTCOME_UNSPECIFIED' | 'OUTCOME_OK' | 'OUTCOME_FAILED' | 'OUTCOME_DEADLINE_EXCEEDED';
                    /**
                     * Contains stdout when code execution is successful, stderr or other description otherwise
                     */
                    output?: string;
                };
            };
            /**
             * https://ai.google.dev/api/caching#VideoMetadata
             */
            metadata: {
                /**
                 * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                startOffset?: string;
                /**
                 * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                endOffset?: string;
                /**
                 * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                 */
                fps?: number;
            };
        }>;
    }>;
    /**
     * A list of Tools the Model may use to generate the next response. A Tool is a piece of code that enables the system to interact with external systems to perform an action, or set of actions, outside of knowledge and scope of the Model. Supported Tools are Function and codeExecution. Refer to the Function calling and the Code execution guides to learn more.
     */
    tools?: Array<{
        functionDeclarations?: Array<{
            /**
             * The name of the function. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
             */
            name: string;
            /**
             * A brief description of the function.
             */
            description: string;
            /**
             * https://ai.google.dev/api/caching#Behavior
             */
            behavior?: 'UNSPECIFIED' | 'BLOCKING' | 'NON_BLOCKING';
            /**
             * Describes the parameters to this function. Reflects the Open API 3.03 Parameter Object string Key: the name of the parameter. Parameter names are case sensitive. Schema Value: the Schema defining the type used for the parameter.
             */
            parameters?: {
                [key: string]: unknown;
            };
            parametersJsonSchema?: unknown;
            response?: unknown;
            responseJsonSchema?: unknown;
        }>;
        /**
         * https://ai.google.dev/api/caching#GoogleSearchRetrieval
         */
        googleSearchRetrieval?: {
            /**
             *
             * Specifies the dynamic retrieval configuration for the given source.
             *
             * https://ai.google.dev/api/caching#DynamicRetrievalConfig
             *
             */
            dynamicRetrievalConfig: {
                /**
                 * https://ai.google.dev/api/caching#Mode
                 */
                mode: 'MODE_UNSPECIFIED' | 'MODE_DYNAMIC';
                dynamicThreshold: number;
            };
        };
        codeExecution?: unknown;
        googleSearch?: unknown;
        urlContext?: unknown;
    }>;
    /**
     * Tool configuration for any Tool specified in the request.
     */
    toolConfig?: {
        functionCallingConfig: {
            mode: 'AUTO' | 'ANY' | 'NONE';
            allowedFunctionNames?: Array<string>;
        };
    };
    /**
     * A list of unique SafetySetting instances for blocking unsafe content.
     */
    safetySettings?: Array<{
        /**
         *
         * The category for this setting
         *
         * https://ai.google.dev/api/generate-content#v1beta.HarmCategory
         *
         */
        category: 'HARM_CATEGORY_UNSPECIFIED' | 'HARM_CATEGORY_DEROGATORY' | 'HARM_CATEGORY_TOXICITY' | 'HARM_CATEGORY_VIOLENCE' | 'HARM_CATEGORY_SEXUAL' | 'HARM_CATEGORY_MEDICAL' | 'HARM_CATEGORY_DANGEROUS' | 'HARM_CATEGORY_HARASSMENT' | 'HARM_CATEGORY_HATE_SPEECH' | 'HARM_CATEGORY_SEXUALLY_EXPLICIT' | 'HARM_CATEGORY_DANGEROUS_CONTENT' | 'HARM_CATEGORY_CIVIC_INTEGRITY';
        /**
         *
         * Controls the probability threshold at which harm is blocked.
         *
         * https://ai.google.dev/api/generate-content#HarmBlockThreshold
         *
         */
        threshold: 'HARM_BLOCK_THRESHOLD_UNSPECIFIED' | 'BLOCK_LOW_AND_ABOVE' | 'BLOCK_MEDIUM_AND_ABOVE' | 'BLOCK_ONLY_HIGH' | 'BLOCK_NONE' | 'OFF';
    }>;
    /**
     * Developer set system instruction(s). Currently, text only.
     */
    systemInstruction?: {
        parts: Array<{
            text: string;
        }>;
    };
    /**
     * https://ai.google.dev/api/generate-content#v1beta.GenerationConfig
     */
    generationConfig?: {
        stopSequences?: Array<string>;
        responseMimeType?: string;
        responseSchema?: unknown;
        _responseJsonSchema?: unknown;
        responseJsonSchema?: unknown;
        responseModalities?: Array<'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO'>;
        candidateCount?: number;
        maxOutputTokens?: number;
        temperature?: number;
        topP?: number;
        topK?: number;
        seed?: number;
        presencePenalty?: number;
        frequencyPenalty?: number;
        responseLogprobs?: boolean;
        logProbs?: number;
        enableEnhancedCivicAnswers?: boolean;
        speechConfig?: unknown;
        thinkingConfig?: unknown;
        imageConfig?: unknown;
        /**
         * https://ai.google.dev/api/generate-content#MediaResolution
         */
        mediaResolution?: 'MEDIA_RESOLUTION_UNSPECIFIED' | 'MEDIA_RESOLUTION_LOW' | 'MEDIA_RESOLUTION_MEDIUM' | 'MEDIA_RESOLUTION_HIGH';
    };
    /**
     * The name of the content cached to use as context to serve the prediction. Format: cachedContents/{cachedContent}
     */
    cachedContent?: string;
};

export type GeminiGenerateContentResponseInput = {
    /**
     * Candidate responses from the model
     */
    candidates: Array<{
        /**
         *
         * The base structured datatype containing multi-part content of a message.
         *
         * A Content includes a role field designating the producer of the Content and a parts field containing multi-part data that contains the content of the message turn.
         *
         * https://ai.google.dev/api/caching#Content
         *
         */
        content: {
            role: 'user' | 'model' | 'function';
            parts: Array<{
                /**
                 * Indicates if the part is thought from the model
                 */
                thought?: boolean;
                /**
                 * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
                 */
                thoughtSignature?: string;
                /**
                 * https://ai.google.dev/api/caching#Part
                 */
                data: {
                    text: string;
                } | {
                    inlineData: {
                        /**
                         * The IANA standard MIME type of the source data. Examples: - image/png - image/jpeg If an unsupported MIME type is provided, an error will be returned
                         */
                        mimeType: string;
                        /**
                         * Raw bytes for media formats. Base64 encoded
                         */
                        data: string;
                    };
                } | {
                    functionCall: {
                        /**
                         * Optional. The unique id of the function call. If populated, the client to execute the functionCall and return the response with the matching id.
                         */
                        id?: string;
                        name: string;
                        /**
                         * The function parameters and values in JSON object format.
                         */
                        args?: {
                            [key: string]: unknown;
                        };
                    };
                } | {
                    functionResponse: {
                        /**
                         * The id of the function call this response is for. Populated by the client to match the corresponding function call id
                         */
                        id?: string;
                        /**
                         * The name of the function to call. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
                         */
                        name: string;
                        /**
                         * The function response in JSON object format.
                         */
                        response: {
                            [key: string]: unknown;
                        };
                        /**
                         * Signals that function call continues, and more responses will be returned, turning the function call into a generator. Is only applicable to NON_BLOCKING function calls, is ignored otherwise. If set to false, future responses will not be considered. It is allowed to return empty response with willContinue=False to signal that the function call is finished. This may still trigger the model generation. To avoid triggering the generation and finish the function call, additionally set scheduling to SILENT
                         */
                        willContinue?: boolean;
                        /**
                         *
                         * Specifies how the response should be scheduled in the conversation. Only applicable to NON_BLOCKING function calls, is ignored otherwise. Defaults to WHEN_IDLE.
                         *
                         * https://ai.google.dev/api/caching#Scheduling
                         *
                         */
                        scheduling?: 'SCHEDULING_UNSPECIFIED' | 'SILENT' | 'WHEN_IDLE' | 'INTERRUPT';
                    };
                } | {
                    fileData: {
                        /**
                         * The IANA standard MIME type of the source data
                         */
                        mimeType?: string;
                        /**
                         * URI
                         */
                        fileUri: string;
                    };
                } | {
                    /**
                     *
                     * Programming language of the code
                     *
                     * https://ai.google.dev/api/caching#Language
                     *
                     */
                    language: 'LANGUAGE_UNSPECIFIED' | 'PYTHON';
                    executableCode: {
                        /**
                         * The code to be executed
                         */
                        code: string;
                    };
                } | {
                    codeExecutionResult: {
                        /**
                         *
                         * Outcome of the code execution.
                         *
                         * https://ai.google.dev/api/caching#Outcome
                         *
                         */
                        outcome: 'OUTCOME_UNSPECIFIED' | 'OUTCOME_OK' | 'OUTCOME_FAILED' | 'OUTCOME_DEADLINE_EXCEEDED';
                        /**
                         * Contains stdout when code execution is successful, stderr or other description otherwise
                         */
                        output?: string;
                    };
                };
                /**
                 * https://ai.google.dev/api/caching#VideoMetadata
                 */
                metadata: {
                    /**
                     * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    startOffset?: string;
                    /**
                     * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    endOffset?: string;
                    /**
                     * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                     */
                    fps?: number;
                };
            }>;
        };
        /**
         *
         * The reason why the model stopped generating tokens.
         *
         * If empty, the model has not stopped generating tokens.
         *
         * https://ai.google.dev/api/generate-content#FinishReason
         *
         */
        finishReason?: 'FINISH_REASON_UNSPECIFIED' | 'STOP' | 'MAX_TOKENS' | 'SAFETY' | 'RECITATION' | 'LANGUAGE' | 'OTHER' | 'BLOCKLIST' | 'PROHIBITED_CONTENT' | 'SPII' | 'MALFORMED_FUNCTION_CALL' | 'IMAGE_SAFETY' | 'IMAGE_PROHIBITED_CONTENT' | 'IMAGE_OTHER' | 'NO_IMAGE' | 'IMAGE_RECITATION' | 'UNEXPECTED_TOOL_CALL' | 'TOO_MANY_TOOL_CALLS';
        safetyRatings: Array<{
            /**
             *
             * The category for this setting
             *
             * https://ai.google.dev/api/generate-content#v1beta.HarmCategory
             *
             */
            category: 'HARM_CATEGORY_UNSPECIFIED' | 'HARM_CATEGORY_DEROGATORY' | 'HARM_CATEGORY_TOXICITY' | 'HARM_CATEGORY_VIOLENCE' | 'HARM_CATEGORY_SEXUAL' | 'HARM_CATEGORY_MEDICAL' | 'HARM_CATEGORY_DANGEROUS' | 'HARM_CATEGORY_HARASSMENT' | 'HARM_CATEGORY_HATE_SPEECH' | 'HARM_CATEGORY_SEXUALLY_EXPLICIT' | 'HARM_CATEGORY_DANGEROUS_CONTENT' | 'HARM_CATEGORY_CIVIC_INTEGRITY';
            /**
             * https://ai.google.dev/api/generate-content#HarmProbability
             */
            probability: 'HARM_PROBABILITY_UNSPECIFIED' | 'NEGLIGIBLE' | 'LOW' | 'MEDIUM' | 'HIGH';
            /**
             * Was this content blocked because of this rating?
             */
            blocked: boolean;
        }>;
        /**
         * https://ai.google.dev/api/generate-content#citationmetadata
         */
        citationMetadata: {
            citationSources: Array<{
                startIndex?: number;
                endIndex?: number;
                uri?: string;
                license?: string;
            }>;
        };
        tokenCount: number;
        groundingAttributions: Array<unknown>;
        groundingMetadata: unknown;
        avgLogprobs: number;
        logprobsResult: unknown;
        urlContextMetadata: unknown;
        /**
         * Index of the candidate in the list of response candidates.
         */
        index: number;
        /**
         * Details the reason why the model stopped generating tokens. This is populated only when finishReason is set.
         */
        finishMessage?: string;
    }>;
    /**
     * Returns the prompt's feedback related to the content filters
     */
    promptFeedback: {
        /**
         * Specifies the reason why the prompt was blocked. https://ai.google.dev/api/generate-content#BlockReason
         */
        blockReason?: 'BLOCK_REASON_UNSPECIFIED' | 'SAFETY' | 'OTHER' | 'BLOCKLIST' | 'PROHIBITED_CONTENT' | 'IMAGE_SAFETY';
        safetyRatings: Array<{
            /**
             *
             * The category for this setting
             *
             * https://ai.google.dev/api/generate-content#v1beta.HarmCategory
             *
             */
            category: 'HARM_CATEGORY_UNSPECIFIED' | 'HARM_CATEGORY_DEROGATORY' | 'HARM_CATEGORY_TOXICITY' | 'HARM_CATEGORY_VIOLENCE' | 'HARM_CATEGORY_SEXUAL' | 'HARM_CATEGORY_MEDICAL' | 'HARM_CATEGORY_DANGEROUS' | 'HARM_CATEGORY_HARASSMENT' | 'HARM_CATEGORY_HATE_SPEECH' | 'HARM_CATEGORY_SEXUALLY_EXPLICIT' | 'HARM_CATEGORY_DANGEROUS_CONTENT' | 'HARM_CATEGORY_CIVIC_INTEGRITY';
            /**
             * https://ai.google.dev/api/generate-content#HarmProbability
             */
            probability: 'HARM_PROBABILITY_UNSPECIFIED' | 'NEGLIGIBLE' | 'LOW' | 'MEDIUM' | 'HIGH';
            /**
             * Was this content blocked because of this rating?
             */
            blocked: boolean;
        }>;
    };
    /**
     * Metadata on the generation requests' token usage
     */
    usageMetadata: {
        promptTokenCount: number;
        cachedContentTokenCount: number;
        candidatesTokenCount: number;
        toolUsePromptTokenCount: number;
        thoughtsTokenCount: number;
        totalTokenCount: number;
        promptTokensDetails: Array<{
            /**
             * https://ai.google.dev/api/generate-content#Modality
             */
            modality: 'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO';
            /**
             * Number of tokens
             */
            tokenCount: number;
        }>;
        cacheTokensDetails: Array<{
            /**
             * https://ai.google.dev/api/generate-content#Modality
             */
            modality: 'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO';
            /**
             * Number of tokens
             */
            tokenCount: number;
        }>;
        candidatesTokensDetails: Array<{
            /**
             * https://ai.google.dev/api/generate-content#Modality
             */
            modality: 'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO';
            /**
             * Number of tokens
             */
            tokenCount: number;
        }>;
        toolUsePromptTokensDetails: Array<{
            /**
             * https://ai.google.dev/api/generate-content#Modality
             */
            modality: 'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO';
            /**
             * Number of tokens
             */
            tokenCount: number;
        }>;
    };
    /**
     * The model version used to generate the response.
     */
    modelVersion: string;
};

export type AnthropicMessagesRequestInput = {
    model: string;
    messages: Array<{
        content: string | Array<{
            text: string;
            type: 'text';
            cache_control?: unknown;
            citations?: Array<unknown> | unknown;
        } | {
            id: string;
            input: unknown;
            name: string;
            type: 'tool_use';
            cache_control?: unknown;
        } | {
            tool_use_id: string;
            type: 'tool_result';
            cache_control?: unknown;
            content?: string | Array<{
                text: string;
                type: 'text';
                cache_control?: unknown;
                citations?: Array<unknown> | unknown;
            }>;
            is_error?: boolean;
        }>;
        role: 'user' | 'assistant';
    }>;
    max_tokens: number;
    container?: string | unknown;
    context_management?: {
        [key: string]: unknown;
    } | unknown;
    mcp_servers?: Array<unknown>;
    metadata?: {
        user_id: string | unknown;
    };
    service_tier?: unknown;
    stop_sequences?: Array<string>;
    stream?: boolean;
    system?: string | {
        type: 'text';
        text: string;
        cache_control?: unknown;
        citations?: Array<unknown> | unknown;
    };
    temperature?: number;
    thinking?: unknown;
    tool_choice?: {
        type: 'auto';
        disable_parallel_tool_use?: boolean;
    } | {
        type: 'any';
        disable_parallel_tool_use?: boolean;
    } | {
        type: 'tool';
        name: string;
        disable_parallel_tool_use?: boolean;
    } | {
        type: 'none';
    };
    tools?: Array<{
        name: string;
        type?: 'custom' | unknown;
        cache_control?: unknown;
        input_schema: {
            [key: string]: unknown;
        };
        description?: string;
    } | {
        name: 'bash';
        type: 'bash_20250124';
        cache_control?: unknown;
    } | {
        name: 'str_replace_editor';
        type: 'text_editor_20250124';
        cache_control?: unknown;
    } | {
        name: 'str_replace_based_edit_tool';
        type: 'text_editor_20250429';
        cache_control?: unknown;
    } | {
        name: 'str_replace_based_edit_tool';
        type: 'text_editor_20250728';
        cache_control?: unknown;
        max_characters?: number | unknown;
    } | {
        name: 'web_search';
        type: 'web_search_20250305';
        allowed_domains?: Array<string> | unknown;
        blocked_domains?: Array<string> | unknown;
        cache_control?: unknown;
        max_uses?: number | unknown;
        user_location?: unknown;
    }>;
    top_k?: number;
    top_p?: number;
};

export type AnthropicMessagesResponseInput = {
    id: string;
    content: Array<{
        citations: Array<unknown> | unknown;
        text: string;
        type: 'text';
    } | {
        signature: string;
        thinking: string;
        type: 'thinking';
    } | {
        data: string;
        type: 'redacted_thinking';
    } | {
        id: string;
        input: unknown;
        name: string;
        type: 'tool_use';
    }>;
    model: string;
    role: 'assistant';
    stop_reason: unknown;
    stop_sequence: string | unknown;
    type: 'message';
    usage: unknown;
};

export type SupportedProviders = 'openai' | 'gemini' | 'anthropic';

export type SupportedProvidersDiscriminator = 'openai:chatCompletions' | 'gemini:generateContent' | 'anthropic:messages';

export type OpenAiChatCompletionRequest = {
    model: string;
    /**
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1186
     */
    messages: Array<{
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'developer';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'system';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L765
             */
            image_url: {
                url: string;
                detail: 'auto' | 'low' | 'high';
            };
        } | {
            type: 'input_audio';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L792
             */
            input_audio: {
                data: string;
                format: 'wav' | 'mp3';
            };
        } | {
            type: 'file';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L732
             */
            file: {
                file_data?: string;
                file_id?: string;
                filename?: string;
            };
        }>;
        role: 'user';
        name?: string;
    } | {
        role: 'assistant';
        audio?: {
            id: string;
        } | unknown;
        content?: string | Array<{
            type: 'text';
            text: string;
        }> | Array<{
            type: 'refusal';
            refusal: string;
        }> | unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L431
         */
        function_call?: {
            arguments: string;
            name: string;
        } | unknown;
        name?: string;
        refusal?: string | unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1197
         */
        tool_calls?: Array<{
            id: string;
            type: 'function';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
             */
            function: {
                arguments: string;
                name: string;
            };
        } | {
            id: string;
            type: 'custom';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
             */
            custom: {
                input: string;
                name: string;
            };
        }>;
    } | {
        role: 'tool';
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        tool_call_id: string;
    } | {
        role: 'function';
        content: string | unknown;
        name: string;
    }>;
    /**
     *
     * A function tool that can be used to generate a response.
     *
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1392
     *
     */
    tools?: Array<{
        type: 'function';
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L174
         */
        function: {
            name: string;
            description?: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            strict?: boolean | unknown;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool, used to identify it in tool calls
             */
            name: string;
            /**
             * Optional description of the custom tool, used to provide more context
             */
            description?: string;
            /**
             * The input format for the custom tool. Default is unconstrained text.
             */
            format?: {
                /**
                 * Unconstrained text format. Always `text`
                 */
                type: 'text';
            } | {
                type: 'grammar';
                /**
                 * Your chosen grammar
                 */
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar definition
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    }>;
    /**
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1405
     */
    tool_choice?: 'none' | 'auto' | 'required' | {
        type: 'allowed_tools';
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1455
         */
        allowed_tools: {
            /**
             *
             * Constrains the tools available to the model to a pre-defined set.
             *
             * auto allows the model to pick from among the allowed tools and generate a
             * message.
             *
             * required requires the model to call one or more of the allowed tools.
             *
             */
            mode: 'auto' | 'required';
            /**
             * A list of tool definitions that the model should be allowed to call
             */
            tools: Array<{
                [key: string]: {
                    type: 'function';
                    /**
                     * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L174
                     */
                    function: {
                        name: string;
                        description?: string;
                        /**
                         *
                         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
                         *
                         * The parameters the functions accepts, described as a JSON Schema object. See the
                         * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
                         * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
                         * documentation about the format.
                         *
                         * Omitting parameters defines a function with an empty parameter list.
                         *
                         */
                        parameters?: {
                            [key: string]: unknown;
                        };
                        strict?: boolean | unknown;
                    };
                };
            }>;
        };
    } | {
        type: 'function';
        function: {
            name: string;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool, used to identify it in tool calls
             */
            name: string;
            /**
             * Optional description of the custom tool, used to provide more context
             */
            description?: string;
            /**
             * The input format for the custom tool. Default is unconstrained text.
             */
            format?: {
                /**
                 * Unconstrained text format. Always `text`
                 */
                type: 'text';
            } | {
                type: 'grammar';
                /**
                 * Your chosen grammar
                 */
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar definition
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    };
    temperature?: number | unknown;
    max_tokens?: number | unknown;
    stream?: boolean | unknown;
};

export type OpenAiChatCompletionResponse = {
    id: string;
    choices: Array<{
        finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
        index: number;
        logprobs: unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1000
         */
        message: {
            content: string | unknown;
            refusal: string | unknown;
            role: 'assistant';
            annotations?: Array<unknown>;
            audio?: unknown;
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L431
             */
            function_call?: {
                arguments: string;
                name: string;
            } | unknown;
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1197
             */
            tool_calls?: Array<{
                id: string;
                type: 'function';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
                 */
                function: {
                    arguments: string;
                    name: string;
                };
            } | {
                id: string;
                type: 'custom';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
                 */
                custom: {
                    input: string;
                    name: string;
                };
            }>;
        };
    }>;
    created: number;
    model: string;
    object: 'chat.completion';
    server_tier?: string;
    system_fingerprint?: string | unknown;
    /**
     * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L113
     */
    usage?: {
        completion_tokens: number;
        prompt_tokens: number;
        total_tokens: number;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L144
         */
        completion_tokens_details?: unknown;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L173
         */
        prompt_tokens_details?: unknown;
    };
};

export type GeminiGenerateContentRequest = {
    /**
     * The content of the current conversation with the model. For single-turn queries, this is a single instance. For multi-turn queries like chat, this is a repeated field that contains the conversation history and the latest request
     */
    contents: Array<{
        role: 'user' | 'model' | 'function';
        parts: Array<{
            /**
             * Indicates if the part is thought from the model
             */
            thought?: boolean;
            /**
             * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
             */
            thoughtSignature?: string;
            /**
             * https://ai.google.dev/api/caching#Part
             */
            data: {
                text: string;
            } | {
                inlineData: {
                    /**
                     * The IANA standard MIME type of the source data. Examples: - image/png - image/jpeg If an unsupported MIME type is provided, an error will be returned
                     */
                    mimeType: string;
                    /**
                     * Raw bytes for media formats. Base64 encoded
                     */
                    data: string;
                };
            } | {
                functionCall: {
                    /**
                     * Optional. The unique id of the function call. If populated, the client to execute the functionCall and return the response with the matching id.
                     */
                    id?: string;
                    name: string;
                    /**
                     * The function parameters and values in JSON object format.
                     */
                    args?: {
                        [key: string]: unknown;
                    };
                };
            } | {
                functionResponse: {
                    /**
                     * The id of the function call this response is for. Populated by the client to match the corresponding function call id
                     */
                    id?: string;
                    /**
                     * The name of the function to call. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
                     */
                    name: string;
                    /**
                     * The function response in JSON object format.
                     */
                    response: {
                        [key: string]: unknown;
                    };
                    /**
                     * Signals that function call continues, and more responses will be returned, turning the function call into a generator. Is only applicable to NON_BLOCKING function calls, is ignored otherwise. If set to false, future responses will not be considered. It is allowed to return empty response with willContinue=False to signal that the function call is finished. This may still trigger the model generation. To avoid triggering the generation and finish the function call, additionally set scheduling to SILENT
                     */
                    willContinue?: boolean;
                    /**
                     *
                     * Specifies how the response should be scheduled in the conversation. Only applicable to NON_BLOCKING function calls, is ignored otherwise. Defaults to WHEN_IDLE.
                     *
                     * https://ai.google.dev/api/caching#Scheduling
                     *
                     */
                    scheduling?: 'SCHEDULING_UNSPECIFIED' | 'SILENT' | 'WHEN_IDLE' | 'INTERRUPT';
                };
            } | {
                fileData: {
                    /**
                     * The IANA standard MIME type of the source data
                     */
                    mimeType?: string;
                    /**
                     * URI
                     */
                    fileUri: string;
                };
            } | {
                /**
                 *
                 * Programming language of the code
                 *
                 * https://ai.google.dev/api/caching#Language
                 *
                 */
                language: 'LANGUAGE_UNSPECIFIED' | 'PYTHON';
                executableCode: {
                    /**
                     * The code to be executed
                     */
                    code: string;
                };
            } | {
                codeExecutionResult: {
                    /**
                     *
                     * Outcome of the code execution.
                     *
                     * https://ai.google.dev/api/caching#Outcome
                     *
                     */
                    outcome: 'OUTCOME_UNSPECIFIED' | 'OUTCOME_OK' | 'OUTCOME_FAILED' | 'OUTCOME_DEADLINE_EXCEEDED';
                    /**
                     * Contains stdout when code execution is successful, stderr or other description otherwise
                     */
                    output?: string;
                };
            };
            /**
             * https://ai.google.dev/api/caching#VideoMetadata
             */
            metadata: {
                /**
                 * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                startOffset?: string;
                /**
                 * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                endOffset?: string;
                /**
                 * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                 */
                fps?: number;
            };
        }>;
    }>;
    /**
     * A list of Tools the Model may use to generate the next response. A Tool is a piece of code that enables the system to interact with external systems to perform an action, or set of actions, outside of knowledge and scope of the Model. Supported Tools are Function and codeExecution. Refer to the Function calling and the Code execution guides to learn more.
     */
    tools?: Array<{
        functionDeclarations?: Array<{
            /**
             * The name of the function. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
             */
            name: string;
            /**
             * A brief description of the function.
             */
            description: string;
            /**
             * https://ai.google.dev/api/caching#Behavior
             */
            behavior?: 'UNSPECIFIED' | 'BLOCKING' | 'NON_BLOCKING';
            /**
             * Describes the parameters to this function. Reflects the Open API 3.03 Parameter Object string Key: the name of the parameter. Parameter names are case sensitive. Schema Value: the Schema defining the type used for the parameter.
             */
            parameters?: {
                [key: string]: unknown;
            };
            parametersJsonSchema?: unknown;
            response?: unknown;
            responseJsonSchema?: unknown;
        }>;
        /**
         * https://ai.google.dev/api/caching#GoogleSearchRetrieval
         */
        googleSearchRetrieval?: {
            /**
             *
             * Specifies the dynamic retrieval configuration for the given source.
             *
             * https://ai.google.dev/api/caching#DynamicRetrievalConfig
             *
             */
            dynamicRetrievalConfig: {
                /**
                 * https://ai.google.dev/api/caching#Mode
                 */
                mode: 'MODE_UNSPECIFIED' | 'MODE_DYNAMIC';
                dynamicThreshold: number;
            };
        };
        codeExecution?: unknown;
        googleSearch?: unknown;
        urlContext?: unknown;
    }>;
    /**
     * Tool configuration for any Tool specified in the request.
     */
    toolConfig?: {
        functionCallingConfig: {
            mode: 'AUTO' | 'ANY' | 'NONE';
            allowedFunctionNames?: Array<string>;
        };
    };
    /**
     * A list of unique SafetySetting instances for blocking unsafe content.
     */
    safetySettings?: Array<{
        /**
         *
         * The category for this setting
         *
         * https://ai.google.dev/api/generate-content#v1beta.HarmCategory
         *
         */
        category: 'HARM_CATEGORY_UNSPECIFIED' | 'HARM_CATEGORY_DEROGATORY' | 'HARM_CATEGORY_TOXICITY' | 'HARM_CATEGORY_VIOLENCE' | 'HARM_CATEGORY_SEXUAL' | 'HARM_CATEGORY_MEDICAL' | 'HARM_CATEGORY_DANGEROUS' | 'HARM_CATEGORY_HARASSMENT' | 'HARM_CATEGORY_HATE_SPEECH' | 'HARM_CATEGORY_SEXUALLY_EXPLICIT' | 'HARM_CATEGORY_DANGEROUS_CONTENT' | 'HARM_CATEGORY_CIVIC_INTEGRITY';
        /**
         *
         * Controls the probability threshold at which harm is blocked.
         *
         * https://ai.google.dev/api/generate-content#HarmBlockThreshold
         *
         */
        threshold: 'HARM_BLOCK_THRESHOLD_UNSPECIFIED' | 'BLOCK_LOW_AND_ABOVE' | 'BLOCK_MEDIUM_AND_ABOVE' | 'BLOCK_ONLY_HIGH' | 'BLOCK_NONE' | 'OFF';
    }>;
    /**
     * Developer set system instruction(s). Currently, text only.
     */
    systemInstruction?: {
        parts: Array<{
            text: string;
        }>;
    };
    /**
     * https://ai.google.dev/api/generate-content#v1beta.GenerationConfig
     */
    generationConfig?: {
        stopSequences?: Array<string>;
        responseMimeType?: string;
        responseSchema?: unknown;
        _responseJsonSchema?: unknown;
        responseJsonSchema?: unknown;
        responseModalities?: Array<'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO'>;
        candidateCount?: number;
        maxOutputTokens?: number;
        temperature?: number;
        topP?: number;
        topK?: number;
        seed?: number;
        presencePenalty?: number;
        frequencyPenalty?: number;
        responseLogprobs?: boolean;
        logProbs?: number;
        enableEnhancedCivicAnswers?: boolean;
        speechConfig?: unknown;
        thinkingConfig?: unknown;
        imageConfig?: unknown;
        /**
         * https://ai.google.dev/api/generate-content#MediaResolution
         */
        mediaResolution?: 'MEDIA_RESOLUTION_UNSPECIFIED' | 'MEDIA_RESOLUTION_LOW' | 'MEDIA_RESOLUTION_MEDIUM' | 'MEDIA_RESOLUTION_HIGH';
    };
    /**
     * The name of the content cached to use as context to serve the prediction. Format: cachedContents/{cachedContent}
     */
    cachedContent?: string;
};

export type GeminiGenerateContentResponse = {
    /**
     * Candidate responses from the model
     */
    candidates: Array<{
        /**
         *
         * The base structured datatype containing multi-part content of a message.
         *
         * A Content includes a role field designating the producer of the Content and a parts field containing multi-part data that contains the content of the message turn.
         *
         * https://ai.google.dev/api/caching#Content
         *
         */
        content: {
            role: 'user' | 'model' | 'function';
            parts: Array<{
                /**
                 * Indicates if the part is thought from the model
                 */
                thought?: boolean;
                /**
                 * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
                 */
                thoughtSignature?: string;
                /**
                 * https://ai.google.dev/api/caching#Part
                 */
                data: {
                    text: string;
                } | {
                    inlineData: {
                        /**
                         * The IANA standard MIME type of the source data. Examples: - image/png - image/jpeg If an unsupported MIME type is provided, an error will be returned
                         */
                        mimeType: string;
                        /**
                         * Raw bytes for media formats. Base64 encoded
                         */
                        data: string;
                    };
                } | {
                    functionCall: {
                        /**
                         * Optional. The unique id of the function call. If populated, the client to execute the functionCall and return the response with the matching id.
                         */
                        id?: string;
                        name: string;
                        /**
                         * The function parameters and values in JSON object format.
                         */
                        args?: {
                            [key: string]: unknown;
                        };
                    };
                } | {
                    functionResponse: {
                        /**
                         * The id of the function call this response is for. Populated by the client to match the corresponding function call id
                         */
                        id?: string;
                        /**
                         * The name of the function to call. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
                         */
                        name: string;
                        /**
                         * The function response in JSON object format.
                         */
                        response: {
                            [key: string]: unknown;
                        };
                        /**
                         * Signals that function call continues, and more responses will be returned, turning the function call into a generator. Is only applicable to NON_BLOCKING function calls, is ignored otherwise. If set to false, future responses will not be considered. It is allowed to return empty response with willContinue=False to signal that the function call is finished. This may still trigger the model generation. To avoid triggering the generation and finish the function call, additionally set scheduling to SILENT
                         */
                        willContinue?: boolean;
                        /**
                         *
                         * Specifies how the response should be scheduled in the conversation. Only applicable to NON_BLOCKING function calls, is ignored otherwise. Defaults to WHEN_IDLE.
                         *
                         * https://ai.google.dev/api/caching#Scheduling
                         *
                         */
                        scheduling?: 'SCHEDULING_UNSPECIFIED' | 'SILENT' | 'WHEN_IDLE' | 'INTERRUPT';
                    };
                } | {
                    fileData: {
                        /**
                         * The IANA standard MIME type of the source data
                         */
                        mimeType?: string;
                        /**
                         * URI
                         */
                        fileUri: string;
                    };
                } | {
                    /**
                     *
                     * Programming language of the code
                     *
                     * https://ai.google.dev/api/caching#Language
                     *
                     */
                    language: 'LANGUAGE_UNSPECIFIED' | 'PYTHON';
                    executableCode: {
                        /**
                         * The code to be executed
                         */
                        code: string;
                    };
                } | {
                    codeExecutionResult: {
                        /**
                         *
                         * Outcome of the code execution.
                         *
                         * https://ai.google.dev/api/caching#Outcome
                         *
                         */
                        outcome: 'OUTCOME_UNSPECIFIED' | 'OUTCOME_OK' | 'OUTCOME_FAILED' | 'OUTCOME_DEADLINE_EXCEEDED';
                        /**
                         * Contains stdout when code execution is successful, stderr or other description otherwise
                         */
                        output?: string;
                    };
                };
                /**
                 * https://ai.google.dev/api/caching#VideoMetadata
                 */
                metadata: {
                    /**
                     * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    startOffset?: string;
                    /**
                     * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    endOffset?: string;
                    /**
                     * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                     */
                    fps?: number;
                };
            }>;
        };
        /**
         *
         * The reason why the model stopped generating tokens.
         *
         * If empty, the model has not stopped generating tokens.
         *
         * https://ai.google.dev/api/generate-content#FinishReason
         *
         */
        finishReason?: 'FINISH_REASON_UNSPECIFIED' | 'STOP' | 'MAX_TOKENS' | 'SAFETY' | 'RECITATION' | 'LANGUAGE' | 'OTHER' | 'BLOCKLIST' | 'PROHIBITED_CONTENT' | 'SPII' | 'MALFORMED_FUNCTION_CALL' | 'IMAGE_SAFETY' | 'IMAGE_PROHIBITED_CONTENT' | 'IMAGE_OTHER' | 'NO_IMAGE' | 'IMAGE_RECITATION' | 'UNEXPECTED_TOOL_CALL' | 'TOO_MANY_TOOL_CALLS';
        safetyRatings: Array<{
            /**
             *
             * The category for this setting
             *
             * https://ai.google.dev/api/generate-content#v1beta.HarmCategory
             *
             */
            category: 'HARM_CATEGORY_UNSPECIFIED' | 'HARM_CATEGORY_DEROGATORY' | 'HARM_CATEGORY_TOXICITY' | 'HARM_CATEGORY_VIOLENCE' | 'HARM_CATEGORY_SEXUAL' | 'HARM_CATEGORY_MEDICAL' | 'HARM_CATEGORY_DANGEROUS' | 'HARM_CATEGORY_HARASSMENT' | 'HARM_CATEGORY_HATE_SPEECH' | 'HARM_CATEGORY_SEXUALLY_EXPLICIT' | 'HARM_CATEGORY_DANGEROUS_CONTENT' | 'HARM_CATEGORY_CIVIC_INTEGRITY';
            /**
             * https://ai.google.dev/api/generate-content#HarmProbability
             */
            probability: 'HARM_PROBABILITY_UNSPECIFIED' | 'NEGLIGIBLE' | 'LOW' | 'MEDIUM' | 'HIGH';
            /**
             * Was this content blocked because of this rating?
             */
            blocked: boolean;
        }>;
        /**
         * https://ai.google.dev/api/generate-content#citationmetadata
         */
        citationMetadata: {
            citationSources: Array<{
                startIndex?: number;
                endIndex?: number;
                uri?: string;
                license?: string;
            }>;
        };
        tokenCount: number;
        groundingAttributions: Array<unknown>;
        groundingMetadata: unknown;
        avgLogprobs: number;
        logprobsResult: unknown;
        urlContextMetadata: unknown;
        /**
         * Index of the candidate in the list of response candidates.
         */
        index: number;
        /**
         * Details the reason why the model stopped generating tokens. This is populated only when finishReason is set.
         */
        finishMessage?: string;
    }>;
    /**
     * Returns the prompt's feedback related to the content filters
     */
    promptFeedback: {
        /**
         * Specifies the reason why the prompt was blocked. https://ai.google.dev/api/generate-content#BlockReason
         */
        blockReason?: 'BLOCK_REASON_UNSPECIFIED' | 'SAFETY' | 'OTHER' | 'BLOCKLIST' | 'PROHIBITED_CONTENT' | 'IMAGE_SAFETY';
        safetyRatings: Array<{
            /**
             *
             * The category for this setting
             *
             * https://ai.google.dev/api/generate-content#v1beta.HarmCategory
             *
             */
            category: 'HARM_CATEGORY_UNSPECIFIED' | 'HARM_CATEGORY_DEROGATORY' | 'HARM_CATEGORY_TOXICITY' | 'HARM_CATEGORY_VIOLENCE' | 'HARM_CATEGORY_SEXUAL' | 'HARM_CATEGORY_MEDICAL' | 'HARM_CATEGORY_DANGEROUS' | 'HARM_CATEGORY_HARASSMENT' | 'HARM_CATEGORY_HATE_SPEECH' | 'HARM_CATEGORY_SEXUALLY_EXPLICIT' | 'HARM_CATEGORY_DANGEROUS_CONTENT' | 'HARM_CATEGORY_CIVIC_INTEGRITY';
            /**
             * https://ai.google.dev/api/generate-content#HarmProbability
             */
            probability: 'HARM_PROBABILITY_UNSPECIFIED' | 'NEGLIGIBLE' | 'LOW' | 'MEDIUM' | 'HIGH';
            /**
             * Was this content blocked because of this rating?
             */
            blocked: boolean;
        }>;
    };
    /**
     * Metadata on the generation requests' token usage
     */
    usageMetadata: {
        promptTokenCount: number;
        cachedContentTokenCount: number;
        candidatesTokenCount: number;
        toolUsePromptTokenCount: number;
        thoughtsTokenCount: number;
        totalTokenCount: number;
        promptTokensDetails: Array<{
            /**
             * https://ai.google.dev/api/generate-content#Modality
             */
            modality: 'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO';
            /**
             * Number of tokens
             */
            tokenCount: number;
        }>;
        cacheTokensDetails: Array<{
            /**
             * https://ai.google.dev/api/generate-content#Modality
             */
            modality: 'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO';
            /**
             * Number of tokens
             */
            tokenCount: number;
        }>;
        candidatesTokensDetails: Array<{
            /**
             * https://ai.google.dev/api/generate-content#Modality
             */
            modality: 'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO';
            /**
             * Number of tokens
             */
            tokenCount: number;
        }>;
        toolUsePromptTokensDetails: Array<{
            /**
             * https://ai.google.dev/api/generate-content#Modality
             */
            modality: 'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO';
            /**
             * Number of tokens
             */
            tokenCount: number;
        }>;
    };
    /**
     * The model version used to generate the response.
     */
    modelVersion: string;
};

export type AnthropicMessagesRequest = {
    model: string;
    messages: Array<{
        content: string | Array<{
            text: string;
            type: 'text';
            cache_control?: unknown;
            citations?: Array<unknown> | unknown;
        } | {
            id: string;
            input: unknown;
            name: string;
            type: 'tool_use';
            cache_control?: unknown;
        } | {
            tool_use_id: string;
            type: 'tool_result';
            cache_control?: unknown;
            content?: string | Array<{
                text: string;
                type: 'text';
                cache_control?: unknown;
                citations?: Array<unknown> | unknown;
            }>;
            is_error?: boolean;
        }>;
        role: 'user' | 'assistant';
    }>;
    max_tokens: number;
    container?: string | unknown;
    context_management?: {
        [key: string]: never;
    } | unknown;
    mcp_servers?: Array<unknown>;
    metadata?: {
        user_id: string | unknown;
    };
    service_tier?: unknown;
    stop_sequences?: Array<string>;
    stream?: boolean;
    system?: string | {
        type: 'text';
        text: string;
        cache_control?: unknown;
        citations?: Array<unknown> | unknown;
    };
    temperature?: number;
    thinking?: unknown;
    tool_choice?: {
        type: 'auto';
        disable_parallel_tool_use?: boolean;
    } | {
        type: 'any';
        disable_parallel_tool_use?: boolean;
    } | {
        type: 'tool';
        name: string;
        disable_parallel_tool_use?: boolean;
    } | {
        type: 'none';
    };
    tools?: Array<{
        name: string;
        type?: 'custom' | unknown;
        cache_control?: unknown;
        input_schema: {
            [key: string]: unknown;
        };
        description?: string;
    } | {
        name: 'bash';
        type: 'bash_20250124';
        cache_control?: unknown;
    } | {
        name: 'str_replace_editor';
        type: 'text_editor_20250124';
        cache_control?: unknown;
    } | {
        name: 'str_replace_based_edit_tool';
        type: 'text_editor_20250429';
        cache_control?: unknown;
    } | {
        name: 'str_replace_based_edit_tool';
        type: 'text_editor_20250728';
        cache_control?: unknown;
        max_characters?: number | unknown;
    } | {
        name: 'web_search';
        type: 'web_search_20250305';
        allowed_domains?: Array<string> | unknown;
        blocked_domains?: Array<string> | unknown;
        cache_control?: unknown;
        max_uses?: number | unknown;
        user_location?: unknown;
    }>;
    top_k?: number;
    top_p?: number;
};

export type AnthropicMessagesResponse = {
    id: string;
    content: Array<{
        citations: Array<unknown> | unknown;
        text: string;
        type: 'text';
    } | {
        signature: string;
        thinking: string;
        type: 'thinking';
    } | {
        data: string;
        type: 'redacted_thinking';
    } | {
        id: string;
        input: unknown;
        name: string;
        type: 'tool_use';
    }>;
    model: string;
    role: 'assistant';
    stop_reason: unknown;
    stop_sequence: string | unknown;
    type: 'message';
    usage: unknown;
};

export type GetOpenapiJsonData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/openapi.json';
};

export type GetOpenapiJsonResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type GetHealthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/health';
};

export type GetHealthResponses = {
    /**
     * Default Response
     */
    200: {
        name: string;
        status: string;
        version: string;
    };
};

export type GetHealthResponse = GetHealthResponses[keyof GetHealthResponses];

export type GetAgentsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/agents';
};

export type GetAgentsErrors = {
    /**
     * Default Response
     */
    401: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetAgentsError = GetAgentsErrors[keyof GetAgentsErrors];

export type GetAgentsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        name: string;
        isDemo: boolean;
        isDefault: boolean;
        createdAt: string;
        updatedAt: string;
        tools: Array<{
            id: string;
            agentId: string | null;
            mcpServerId: string | null;
            name: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            description: string | null;
            createdAt: string;
            updatedAt: string;
        }>;
        usersWithAccess: Array<string>;
    }>;
};

export type GetAgentsResponse = GetAgentsResponses[keyof GetAgentsResponses];

export type CreateAgentData = {
    body: {
        name: string;
        isDemo?: boolean;
        isDefault?: boolean;
        usersWithAccess: Array<string>;
    };
    path?: never;
    query?: never;
    url: '/api/agents';
};

export type CreateAgentErrors = {
    /**
     * Default Response
     */
    401: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type CreateAgentError = CreateAgentErrors[keyof CreateAgentErrors];

export type CreateAgentResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        isDemo: boolean;
        isDefault: boolean;
        createdAt: string;
        updatedAt: string;
        tools: Array<{
            id: string;
            agentId: string | null;
            mcpServerId: string | null;
            name: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            description: string | null;
            createdAt: string;
            updatedAt: string;
        }>;
        usersWithAccess: Array<string>;
    };
};

export type CreateAgentResponse = CreateAgentResponses[keyof CreateAgentResponses];

export type GetDefaultAgentData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/agents/default';
};

export type GetDefaultAgentErrors = {
    /**
     * Default Response
     */
    401: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetDefaultAgentError = GetDefaultAgentErrors[keyof GetDefaultAgentErrors];

export type GetDefaultAgentResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        isDemo: boolean;
        isDefault: boolean;
        createdAt: string;
        updatedAt: string;
        tools: Array<{
            id: string;
            agentId: string | null;
            mcpServerId: string | null;
            name: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            description: string | null;
            createdAt: string;
            updatedAt: string;
        }>;
        usersWithAccess: Array<string>;
    };
};

export type GetDefaultAgentResponse = GetDefaultAgentResponses[keyof GetDefaultAgentResponses];

export type DeleteAgentData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/agents/{id}';
};

export type DeleteAgentErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type DeleteAgentError = DeleteAgentErrors[keyof DeleteAgentErrors];

export type DeleteAgentResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteAgentResponse = DeleteAgentResponses[keyof DeleteAgentResponses];

export type GetAgentData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/agents/{id}';
};

export type GetAgentErrors = {
    /**
     * Default Response
     */
    401: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetAgentError = GetAgentErrors[keyof GetAgentErrors];

export type GetAgentResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        isDemo: boolean;
        isDefault: boolean;
        createdAt: string;
        updatedAt: string;
        tools: Array<{
            id: string;
            agentId: string | null;
            mcpServerId: string | null;
            name: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            description: string | null;
            createdAt: string;
            updatedAt: string;
        }>;
        usersWithAccess: Array<string>;
    };
};

export type GetAgentResponse = GetAgentResponses[keyof GetAgentResponses];

export type UpdateAgentData = {
    body?: {
        name?: string;
        isDemo?: boolean;
        isDefault?: boolean;
        usersWithAccess?: Array<string>;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/agents/{id}';
};

export type UpdateAgentErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type UpdateAgentError = UpdateAgentErrors[keyof UpdateAgentErrors];

export type UpdateAgentResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        isDemo: boolean;
        isDefault: boolean;
        createdAt: string;
        updatedAt: string;
        tools: Array<{
            id: string;
            agentId: string | null;
            mcpServerId: string | null;
            name: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            description: string | null;
            createdAt: string;
            updatedAt: string;
        }>;
        usersWithAccess: Array<string>;
    };
};

export type UpdateAgentResponse = UpdateAgentResponses[keyof UpdateAgentResponses];

export type GetAllAgentToolsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/agent-tools';
};

export type GetAllAgentToolsErrors = {
    /**
     * Default Response
     */
    401: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetAllAgentToolsError = GetAllAgentToolsErrors[keyof GetAllAgentToolsErrors];

export type GetAllAgentToolsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        allowUsageWhenUntrustedDataIsPresent: boolean;
        toolResultTreatment: 'trusted' | 'sanitize_with_dual_llm' | 'untrusted';
        responseModifierTemplate: string | null;
        createdAt: string;
        updatedAt: string;
        agent: {
            id: string;
            name: string;
        };
        tool: {
            id: string;
            name: string;
            description: string | null;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            createdAt: string;
            updatedAt: string;
            mcpServerId: string | null;
            mcpServerName: string | null;
        };
    }>;
};

export type GetAllAgentToolsResponse = GetAllAgentToolsResponses[keyof GetAllAgentToolsResponses];

export type UnassignToolFromAgentData = {
    body?: never;
    path: {
        agentId: string;
        toolId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}/tools/{toolId}';
};

export type UnassignToolFromAgentErrors = {
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type UnassignToolFromAgentError = UnassignToolFromAgentErrors[keyof UnassignToolFromAgentErrors];

export type UnassignToolFromAgentResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type UnassignToolFromAgentResponse = UnassignToolFromAgentResponses[keyof UnassignToolFromAgentResponses];

export type AssignToolToAgentData = {
    body?: never;
    path: {
        agentId: string;
        toolId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}/tools/{toolId}';
};

export type AssignToolToAgentErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type AssignToolToAgentError = AssignToolToAgentErrors[keyof AssignToolToAgentErrors];

export type AssignToolToAgentResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type AssignToolToAgentResponse = AssignToolToAgentResponses[keyof AssignToolToAgentResponses];

export type GetAgentToolsData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}/tools';
};

export type GetAgentToolsErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetAgentToolsError = GetAgentToolsErrors[keyof GetAgentToolsErrors];

export type GetAgentToolsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        agentId: string | null;
        mcpServerId: string | null;
        name: string;
        /**
         *
         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
         *
         * The parameters the functions accepts, described as a JSON Schema object. See the
         * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
         * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
         * documentation about the format.
         *
         * Omitting parameters defines a function with an empty parameter list.
         *
         */
        parameters?: {
            [key: string]: unknown;
        };
        description: string | null;
        createdAt: string;
        updatedAt: string;
    }>;
};

export type GetAgentToolsResponse = GetAgentToolsResponses[keyof GetAgentToolsResponses];

export type UpdateAgentToolData = {
    body?: {
        allowUsageWhenUntrustedDataIsPresent?: boolean;
        toolResultTreatment?: 'trusted' | 'sanitize_with_dual_llm' | 'untrusted';
        responseModifierTemplate?: string | null;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/agent-tools/{id}';
};

export type UpdateAgentToolErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type UpdateAgentToolError = UpdateAgentToolErrors[keyof UpdateAgentToolErrors];

export type UpdateAgentToolResponses = {
    /**
     * Default Response
     */
    200: {
        id?: string;
        agentId?: string;
        toolId?: string;
        allowUsageWhenUntrustedDataIsPresent?: boolean;
        toolResultTreatment: 'trusted' | 'sanitize_with_dual_llm' | 'untrusted';
        responseModifierTemplate?: string | null;
        createdAt?: string;
        updatedAt?: string;
    };
};

export type UpdateAgentToolResponse = UpdateAgentToolResponses[keyof UpdateAgentToolResponses];

export type DeleteV1AnthropicData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/anthropic/';
};

export type DeleteV1AnthropicResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type GetV1AnthropicData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/anthropic/';
};

export type GetV1AnthropicResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type HeadV1AnthropicData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/anthropic/';
};

export type HeadV1AnthropicResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type OptionsV1AnthropicData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/anthropic/';
};

export type OptionsV1AnthropicResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PatchV1AnthropicData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/anthropic/';
};

export type PatchV1AnthropicResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PostV1AnthropicData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/anthropic/';
};

export type PostV1AnthropicResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PutV1AnthropicData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/anthropic/';
};

export type PutV1AnthropicResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type DeleteV1AnthropicBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/anthropic/{*}';
};

export type DeleteV1AnthropicBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type GetV1AnthropicBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/anthropic/{*}';
};

export type GetV1AnthropicBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type HeadV1AnthropicBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/anthropic/{*}';
};

export type HeadV1AnthropicBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type OptionsV1AnthropicBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/anthropic/{*}';
};

export type OptionsV1AnthropicBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PatchV1AnthropicBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/anthropic/{*}';
};

export type PatchV1AnthropicBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PostV1AnthropicBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/anthropic/{*}';
};

export type PostV1AnthropicBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PutV1AnthropicBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/anthropic/{*}';
};

export type PutV1AnthropicBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type DeleteV1AnthropicV1ByAgentIdData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/anthropic/v1/{agentId}/';
};

export type DeleteV1AnthropicV1ByAgentIdResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type GetV1AnthropicV1ByAgentIdData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/anthropic/v1/{agentId}/';
};

export type GetV1AnthropicV1ByAgentIdResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type HeadV1AnthropicV1ByAgentIdData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/anthropic/v1/{agentId}/';
};

export type HeadV1AnthropicV1ByAgentIdResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type OptionsV1AnthropicV1ByAgentIdData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/anthropic/v1/{agentId}/';
};

export type OptionsV1AnthropicV1ByAgentIdResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PatchV1AnthropicV1ByAgentIdData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/anthropic/v1/{agentId}/';
};

export type PatchV1AnthropicV1ByAgentIdResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PostV1AnthropicV1ByAgentIdData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/anthropic/v1/{agentId}/';
};

export type PostV1AnthropicV1ByAgentIdResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PutV1AnthropicV1ByAgentIdData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/anthropic/v1/{agentId}/';
};

export type PutV1AnthropicV1ByAgentIdResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type DeleteV1AnthropicV1ByAgentIdBy__Data = {
    body?: never;
    path: {
        agentId: string;
        '*': string;
    };
    query?: never;
    url: '/v1/anthropic/v1/{agentId}/{*}';
};

export type DeleteV1AnthropicV1ByAgentIdBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type GetV1AnthropicV1ByAgentIdBy__Data = {
    body?: never;
    path: {
        agentId: string;
        '*': string;
    };
    query?: never;
    url: '/v1/anthropic/v1/{agentId}/{*}';
};

export type GetV1AnthropicV1ByAgentIdBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type HeadV1AnthropicV1ByAgentIdBy__Data = {
    body?: never;
    path: {
        agentId: string;
        '*': string;
    };
    query?: never;
    url: '/v1/anthropic/v1/{agentId}/{*}';
};

export type HeadV1AnthropicV1ByAgentIdBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type OptionsV1AnthropicV1ByAgentIdBy__Data = {
    body?: never;
    path: {
        agentId: string;
        '*': string;
    };
    query?: never;
    url: '/v1/anthropic/v1/{agentId}/{*}';
};

export type OptionsV1AnthropicV1ByAgentIdBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PatchV1AnthropicV1ByAgentIdBy__Data = {
    body?: never;
    path: {
        agentId: string;
        '*': string;
    };
    query?: never;
    url: '/v1/anthropic/v1/{agentId}/{*}';
};

export type PatchV1AnthropicV1ByAgentIdBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PostV1AnthropicV1ByAgentIdBy__Data = {
    body?: never;
    path: {
        agentId: string;
        '*': string;
    };
    query?: never;
    url: '/v1/anthropic/v1/{agentId}/{*}';
};

export type PostV1AnthropicV1ByAgentIdBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PutV1AnthropicV1ByAgentIdBy__Data = {
    body?: never;
    path: {
        agentId: string;
        '*': string;
    };
    query?: never;
    url: '/v1/anthropic/v1/{agentId}/{*}';
};

export type PutV1AnthropicV1ByAgentIdBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type AnthropicMessagesWithDefaultAgentData = {
    body?: AnthropicMessagesRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        'anthropic-version': string;
        'x-api-key': string;
    };
    path?: never;
    query?: never;
    url: '/v1/anthropic/v1/messages';
};

export type AnthropicMessagesWithDefaultAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    403: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type AnthropicMessagesWithDefaultAgentError = AnthropicMessagesWithDefaultAgentErrors[keyof AnthropicMessagesWithDefaultAgentErrors];

export type AnthropicMessagesWithDefaultAgentResponses = {
    /**
     * Default Response
     */
    200: AnthropicMessagesResponse;
};

export type AnthropicMessagesWithDefaultAgentResponse = AnthropicMessagesWithDefaultAgentResponses[keyof AnthropicMessagesWithDefaultAgentResponses];

export type AnthropicMessagesWithAgentData = {
    body?: AnthropicMessagesRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        'anthropic-version': string;
        'x-api-key': string;
    };
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/anthropic/v1/{agentId}/messages';
};

export type AnthropicMessagesWithAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    403: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type AnthropicMessagesWithAgentError = AnthropicMessagesWithAgentErrors[keyof AnthropicMessagesWithAgentErrors];

export type AnthropicMessagesWithAgentResponses = {
    /**
     * Default Response
     */
    200: AnthropicMessagesResponse;
};

export type AnthropicMessagesWithAgentResponse = AnthropicMessagesWithAgentResponses[keyof AnthropicMessagesWithAgentResponses];

export type GetDefaultCredentialsStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth/default-credentials-status';
};

export type GetDefaultCredentialsStatusErrors = {
    /**
     * Default Response
     */
    500: {
        enabled: boolean;
    };
};

export type GetDefaultCredentialsStatusError = GetDefaultCredentialsStatusErrors[keyof GetDefaultCredentialsStatusErrors];

export type GetDefaultCredentialsStatusResponses = {
    /**
     * Default Response
     */
    200: {
        enabled: boolean;
    };
};

export type GetDefaultCredentialsStatusResponse = GetDefaultCredentialsStatusResponses[keyof GetDefaultCredentialsStatusResponses];

export type GetApiAuthBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/api/auth/{*}';
};

export type GetApiAuthBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PostApiAuthBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/api/auth/{*}';
};

export type PostApiAuthBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type GetOperatorsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/autonomy-policies/operators';
};

export type GetOperatorsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        value: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
        label: string;
    }>;
};

export type GetOperatorsResponse = GetOperatorsResponses[keyof GetOperatorsResponses];

export type GetToolInvocationPoliciesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/autonomy-policies/tool-invocation';
};

export type GetToolInvocationPoliciesErrors = {
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetToolInvocationPoliciesError = GetToolInvocationPoliciesErrors[keyof GetToolInvocationPoliciesErrors];

export type GetToolInvocationPoliciesResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        agentToolId: string;
        argumentName: string;
        operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
        value: string;
        action: 'allow_when_context_is_untrusted' | 'block_always';
        reason: string | null;
        createdAt: string;
        updatedAt: string;
    }>;
};

export type GetToolInvocationPoliciesResponse = GetToolInvocationPoliciesResponses[keyof GetToolInvocationPoliciesResponses];

export type CreateToolInvocationPolicyData = {
    body: {
        agentToolId: string;
        argumentName: string;
        operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
        value: string;
        action: 'allow_when_context_is_untrusted' | 'block_always';
        reason?: string | null;
    };
    path?: never;
    query?: never;
    url: '/api/autonomy-policies/tool-invocation';
};

export type CreateToolInvocationPolicyErrors = {
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type CreateToolInvocationPolicyError = CreateToolInvocationPolicyErrors[keyof CreateToolInvocationPolicyErrors];

export type CreateToolInvocationPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        agentToolId: string;
        argumentName: string;
        operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
        value: string;
        action: 'allow_when_context_is_untrusted' | 'block_always';
        reason: string | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type CreateToolInvocationPolicyResponse = CreateToolInvocationPolicyResponses[keyof CreateToolInvocationPolicyResponses];

export type DeleteToolInvocationPolicyData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/autonomy-policies/tool-invocation/{id}';
};

export type DeleteToolInvocationPolicyErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type DeleteToolInvocationPolicyError = DeleteToolInvocationPolicyErrors[keyof DeleteToolInvocationPolicyErrors];

export type DeleteToolInvocationPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteToolInvocationPolicyResponse = DeleteToolInvocationPolicyResponses[keyof DeleteToolInvocationPolicyResponses];

export type GetToolInvocationPolicyData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/autonomy-policies/tool-invocation/{id}';
};

export type GetToolInvocationPolicyErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetToolInvocationPolicyError = GetToolInvocationPolicyErrors[keyof GetToolInvocationPolicyErrors];

export type GetToolInvocationPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        agentToolId: string;
        argumentName: string;
        operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
        value: string;
        action: 'allow_when_context_is_untrusted' | 'block_always';
        reason: string | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type GetToolInvocationPolicyResponse = GetToolInvocationPolicyResponses[keyof GetToolInvocationPolicyResponses];

export type UpdateToolInvocationPolicyData = {
    body?: {
        agentToolId?: string;
        argumentName?: string;
        operator?: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
        value?: string;
        action?: 'allow_when_context_is_untrusted' | 'block_always';
        reason?: string | null;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/autonomy-policies/tool-invocation/{id}';
};

export type UpdateToolInvocationPolicyErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type UpdateToolInvocationPolicyError = UpdateToolInvocationPolicyErrors[keyof UpdateToolInvocationPolicyErrors];

export type UpdateToolInvocationPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        agentToolId: string;
        argumentName: string;
        operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
        value: string;
        action: 'allow_when_context_is_untrusted' | 'block_always';
        reason: string | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type UpdateToolInvocationPolicyResponse = UpdateToolInvocationPolicyResponses[keyof UpdateToolInvocationPolicyResponses];

export type GetTrustedDataPoliciesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/trusted-data-policies';
};

export type GetTrustedDataPoliciesErrors = {
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetTrustedDataPoliciesError = GetTrustedDataPoliciesErrors[keyof GetTrustedDataPoliciesErrors];

export type GetTrustedDataPoliciesResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        agentToolId: string;
        description: string;
        attributePath: string;
        operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
        value: string;
        action: 'block_always' | 'mark_as_trusted' | 'sanitize_with_dual_llm';
        createdAt: string;
        updatedAt: string;
    }>;
};

export type GetTrustedDataPoliciesResponse = GetTrustedDataPoliciesResponses[keyof GetTrustedDataPoliciesResponses];

export type CreateTrustedDataPolicyData = {
    body: {
        agentToolId: string;
        description: string;
        attributePath: string;
        operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
        value: string;
        action: 'block_always' | 'mark_as_trusted' | 'sanitize_with_dual_llm';
    };
    path?: never;
    query?: never;
    url: '/api/trusted-data-policies';
};

export type CreateTrustedDataPolicyErrors = {
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type CreateTrustedDataPolicyError = CreateTrustedDataPolicyErrors[keyof CreateTrustedDataPolicyErrors];

export type CreateTrustedDataPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        agentToolId: string;
        description: string;
        attributePath: string;
        operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
        value: string;
        action: 'block_always' | 'mark_as_trusted' | 'sanitize_with_dual_llm';
        createdAt: string;
        updatedAt: string;
    };
};

export type CreateTrustedDataPolicyResponse = CreateTrustedDataPolicyResponses[keyof CreateTrustedDataPolicyResponses];

export type DeleteTrustedDataPolicyData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/trusted-data-policies/{id}';
};

export type DeleteTrustedDataPolicyErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type DeleteTrustedDataPolicyError = DeleteTrustedDataPolicyErrors[keyof DeleteTrustedDataPolicyErrors];

export type DeleteTrustedDataPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteTrustedDataPolicyResponse = DeleteTrustedDataPolicyResponses[keyof DeleteTrustedDataPolicyResponses];

export type GetTrustedDataPolicyData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/trusted-data-policies/{id}';
};

export type GetTrustedDataPolicyErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetTrustedDataPolicyError = GetTrustedDataPolicyErrors[keyof GetTrustedDataPolicyErrors];

export type GetTrustedDataPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        agentToolId: string;
        description: string;
        attributePath: string;
        operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
        value: string;
        action: 'block_always' | 'mark_as_trusted' | 'sanitize_with_dual_llm';
        createdAt: string;
        updatedAt: string;
    };
};

export type GetTrustedDataPolicyResponse = GetTrustedDataPolicyResponses[keyof GetTrustedDataPolicyResponses];

export type UpdateTrustedDataPolicyData = {
    body?: {
        agentToolId?: string;
        description?: string;
        attributePath?: string;
        operator?: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
        value?: string;
        action?: 'block_always' | 'mark_as_trusted' | 'sanitize_with_dual_llm';
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/trusted-data-policies/{id}';
};

export type UpdateTrustedDataPolicyErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type UpdateTrustedDataPolicyError = UpdateTrustedDataPolicyErrors[keyof UpdateTrustedDataPolicyErrors];

export type UpdateTrustedDataPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        agentToolId: string;
        description: string;
        attributePath: string;
        operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
        value: string;
        action: 'block_always' | 'mark_as_trusted' | 'sanitize_with_dual_llm';
        createdAt: string;
        updatedAt: string;
    };
};

export type UpdateTrustedDataPolicyResponse = UpdateTrustedDataPolicyResponses[keyof UpdateTrustedDataPolicyResponses];

export type GetDefaultDualLlmConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/dual-llm-config/default';
};

export type GetDefaultDualLlmConfigErrors = {
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetDefaultDualLlmConfigError = GetDefaultDualLlmConfigErrors[keyof GetDefaultDualLlmConfigErrors];

export type GetDefaultDualLlmConfigResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        enabled: boolean;
        mainAgentPrompt: string;
        quarantinedAgentPrompt: string;
        summaryPrompt: string;
        maxRounds: number;
        createdAt: string;
        updatedAt: string;
    };
};

export type GetDefaultDualLlmConfigResponse = GetDefaultDualLlmConfigResponses[keyof GetDefaultDualLlmConfigResponses];

export type GetDualLlmConfigsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/dual-llm-config';
};

export type GetDualLlmConfigsErrors = {
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetDualLlmConfigsError = GetDualLlmConfigsErrors[keyof GetDualLlmConfigsErrors];

export type GetDualLlmConfigsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        enabled: boolean;
        mainAgentPrompt: string;
        quarantinedAgentPrompt: string;
        summaryPrompt: string;
        maxRounds: number;
        createdAt: string;
        updatedAt: string;
    }>;
};

export type GetDualLlmConfigsResponse = GetDualLlmConfigsResponses[keyof GetDualLlmConfigsResponses];

export type CreateDualLlmConfigData = {
    body: {
        enabled?: boolean;
        mainAgentPrompt: string;
        quarantinedAgentPrompt: string;
        summaryPrompt: string;
        maxRounds?: number;
    };
    path?: never;
    query?: never;
    url: '/api/dual-llm-config';
};

export type CreateDualLlmConfigErrors = {
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type CreateDualLlmConfigError = CreateDualLlmConfigErrors[keyof CreateDualLlmConfigErrors];

export type CreateDualLlmConfigResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        enabled: boolean;
        mainAgentPrompt: string;
        quarantinedAgentPrompt: string;
        summaryPrompt: string;
        maxRounds: number;
        createdAt: string;
        updatedAt: string;
    };
};

export type CreateDualLlmConfigResponse = CreateDualLlmConfigResponses[keyof CreateDualLlmConfigResponses];

export type DeleteDualLlmConfigData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/dual-llm-config/{id}';
};

export type DeleteDualLlmConfigErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type DeleteDualLlmConfigError = DeleteDualLlmConfigErrors[keyof DeleteDualLlmConfigErrors];

export type DeleteDualLlmConfigResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteDualLlmConfigResponse = DeleteDualLlmConfigResponses[keyof DeleteDualLlmConfigResponses];

export type GetDualLlmConfigData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/dual-llm-config/{id}';
};

export type GetDualLlmConfigErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetDualLlmConfigError = GetDualLlmConfigErrors[keyof GetDualLlmConfigErrors];

export type GetDualLlmConfigResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        enabled: boolean;
        mainAgentPrompt: string;
        quarantinedAgentPrompt: string;
        summaryPrompt: string;
        maxRounds: number;
        createdAt: string;
        updatedAt: string;
    };
};

export type GetDualLlmConfigResponse = GetDualLlmConfigResponses[keyof GetDualLlmConfigResponses];

export type UpdateDualLlmConfigData = {
    body?: {
        enabled?: boolean;
        mainAgentPrompt?: string;
        quarantinedAgentPrompt?: string;
        summaryPrompt?: string;
        maxRounds?: number;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/dual-llm-config/{id}';
};

export type UpdateDualLlmConfigErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type UpdateDualLlmConfigError = UpdateDualLlmConfigErrors[keyof UpdateDualLlmConfigErrors];

export type UpdateDualLlmConfigResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        enabled: boolean;
        mainAgentPrompt: string;
        quarantinedAgentPrompt: string;
        summaryPrompt: string;
        maxRounds: number;
        createdAt: string;
        updatedAt: string;
    };
};

export type UpdateDualLlmConfigResponse = UpdateDualLlmConfigResponses[keyof UpdateDualLlmConfigResponses];

export type GetDualLlmResultByToolCallIdData = {
    body?: never;
    path: {
        toolCallId: string;
    };
    query?: never;
    url: '/api/dual-llm-results/by-tool-call-id/{toolCallId}';
};

export type GetDualLlmResultByToolCallIdErrors = {
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetDualLlmResultByToolCallIdError = GetDualLlmResultByToolCallIdErrors[keyof GetDualLlmResultByToolCallIdErrors];

export type GetDualLlmResultByToolCallIdResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        agentId: string;
        toolCallId: string;
        conversations: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown>;
        result: string;
        createdAt: string;
    } | null;
};

export type GetDualLlmResultByToolCallIdResponse = GetDualLlmResultByToolCallIdResponses[keyof GetDualLlmResultByToolCallIdResponses];

export type GetDualLlmResultsByInteractionData = {
    body?: never;
    path: {
        interactionId: string;
    };
    query?: never;
    url: '/api/dual-llm-results/by-interaction/{interactionId}';
};

export type GetDualLlmResultsByInteractionErrors = {
    /**
     * Default Response
     */
    401: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetDualLlmResultsByInteractionError = GetDualLlmResultsByInteractionErrors[keyof GetDualLlmResultsByInteractionErrors];

export type GetDualLlmResultsByInteractionResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        agentId: string;
        toolCallId: string;
        conversations: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown>;
        result: string;
        createdAt: string;
    }>;
};

export type GetDualLlmResultsByInteractionResponse = GetDualLlmResultsByInteractionResponses[keyof GetDualLlmResultsByInteractionResponses];

export type GetFeaturesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/features';
};

export type GetFeaturesResponses = {
    /**
     * Default Response
     */
    200: {
        mcp_registry: boolean;
    };
};

export type GetFeaturesResponse = GetFeaturesResponses[keyof GetFeaturesResponses];

export type DeleteV1GeminiData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/gemini/';
};

export type DeleteV1GeminiResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type GetV1GeminiData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/gemini/';
};

export type GetV1GeminiResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type HeadV1GeminiData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/gemini/';
};

export type HeadV1GeminiResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type OptionsV1GeminiData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/gemini/';
};

export type OptionsV1GeminiResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PatchV1GeminiData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/gemini/';
};

export type PatchV1GeminiResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PostV1GeminiData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/gemini/';
};

export type PostV1GeminiResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PutV1GeminiData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/gemini/';
};

export type PutV1GeminiResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type DeleteV1GeminiBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/gemini/{*}';
};

export type DeleteV1GeminiBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type GetV1GeminiBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/gemini/{*}';
};

export type GetV1GeminiBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type HeadV1GeminiBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/gemini/{*}';
};

export type HeadV1GeminiBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type OptionsV1GeminiBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/gemini/{*}';
};

export type OptionsV1GeminiBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PatchV1GeminiBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/gemini/{*}';
};

export type PatchV1GeminiBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PostV1GeminiBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/gemini/{*}';
};

export type PostV1GeminiBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PutV1GeminiBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/gemini/{*}';
};

export type PutV1GeminiBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PostV1GeminiModelsByModelGenerateContentData = {
    body?: GeminiGenerateContentRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * API key for Google Gemini
         */
        'x-goog-api-key': string;
    };
    path: {
        /**
         * The model to use
         */
        model: string;
    };
    query?: never;
    url: '/v1/gemini/models/{model}:generateContent';
};

export type PostV1GeminiModelsByModelGenerateContentErrors = {
    /**
     * Default Response
     */
    400: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    403: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type PostV1GeminiModelsByModelGenerateContentError = PostV1GeminiModelsByModelGenerateContentErrors[keyof PostV1GeminiModelsByModelGenerateContentErrors];

export type PostV1GeminiModelsByModelGenerateContentResponses = {
    /**
     * Default Response
     */
    200: GeminiGenerateContentResponse;
};

export type PostV1GeminiModelsByModelGenerateContentResponse = PostV1GeminiModelsByModelGenerateContentResponses[keyof PostV1GeminiModelsByModelGenerateContentResponses];

export type PostV1GeminiModelsByModelStreamGenerateContentData = {
    body?: GeminiGenerateContentRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * API key for Google Gemini
         */
        'x-goog-api-key': string;
    };
    path: {
        /**
         * The model to use
         */
        model: string;
    };
    query?: never;
    url: '/v1/gemini/models/{model}:streamGenerateContent';
};

export type PostV1GeminiModelsByModelStreamGenerateContentErrors = {
    /**
     * Default Response
     */
    400: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    403: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type PostV1GeminiModelsByModelStreamGenerateContentError = PostV1GeminiModelsByModelStreamGenerateContentErrors[keyof PostV1GeminiModelsByModelStreamGenerateContentErrors];

export type PostV1GeminiByAgentIdModelsByModelGenerateContentData = {
    body?: GeminiGenerateContentRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * API key for Google Gemini
         */
        'x-goog-api-key': string;
    };
    path: {
        agentId: string;
        /**
         * The model to use
         */
        model: string;
    };
    query?: never;
    url: '/v1/gemini/{agentId}/models/{model}:generateContent';
};

export type PostV1GeminiByAgentIdModelsByModelGenerateContentErrors = {
    /**
     * Default Response
     */
    400: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    403: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type PostV1GeminiByAgentIdModelsByModelGenerateContentError = PostV1GeminiByAgentIdModelsByModelGenerateContentErrors[keyof PostV1GeminiByAgentIdModelsByModelGenerateContentErrors];

export type PostV1GeminiByAgentIdModelsByModelGenerateContentResponses = {
    /**
     * Default Response
     */
    200: GeminiGenerateContentResponse;
};

export type PostV1GeminiByAgentIdModelsByModelGenerateContentResponse = PostV1GeminiByAgentIdModelsByModelGenerateContentResponses[keyof PostV1GeminiByAgentIdModelsByModelGenerateContentResponses];

export type PostV1GeminiByAgentIdModelsByModelStreamGenerateContentData = {
    body?: GeminiGenerateContentRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * API key for Google Gemini
         */
        'x-goog-api-key': string;
    };
    path: {
        agentId: string;
        /**
         * The model to use
         */
        model: string;
    };
    query?: never;
    url: '/v1/gemini/{agentId}/models/{model}:streamGenerateContent';
};

export type PostV1GeminiByAgentIdModelsByModelStreamGenerateContentErrors = {
    /**
     * Default Response
     */
    400: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    403: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type PostV1GeminiByAgentIdModelsByModelStreamGenerateContentError = PostV1GeminiByAgentIdModelsByModelStreamGenerateContentErrors[keyof PostV1GeminiByAgentIdModelsByModelStreamGenerateContentErrors];

export type GetInteractionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by agent ID
         */
        agentId?: string;
        limit?: number;
        offset?: number;
        sortBy?: 'createdAt' | 'agentId' | 'model';
        sortDirection?: 'asc' | 'desc';
    };
    url: '/api/interactions';
};

export type GetInteractionsErrors = {
    /**
     * Default Response
     */
    401: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetInteractionsError = GetInteractionsErrors[keyof GetInteractionsErrors];

export type GetInteractionsResponses = {
    /**
     * Default Response
     */
    200: {
        data: Array<{
            id: string;
            agentId: string;
            request: OpenAiChatCompletionRequest;
            response: OpenAiChatCompletionResponse;
            type: 'openai:chatCompletions';
            createdAt: string;
        } | {
            id: string;
            agentId: string;
            request: GeminiGenerateContentRequest;
            response: GeminiGenerateContentResponse;
            type: 'gemini:generateContent';
            createdAt: string;
        } | {
            id: string;
            agentId: string;
            request: AnthropicMessagesRequest;
            response: AnthropicMessagesResponse;
            type: 'anthropic:messages';
            createdAt: string;
        }>;
        pagination: {
            currentPage: number;
            limit: number;
            total: number;
            totalPages: number;
            hasNext: boolean;
            hasPrev: boolean;
        };
    };
};

export type GetInteractionsResponse = GetInteractionsResponses[keyof GetInteractionsResponses];

export type GetInteractionData = {
    body?: never;
    path: {
        interactionId: string;
    };
    query?: never;
    url: '/api/interactions/{interactionId}';
};

export type GetInteractionErrors = {
    /**
     * Default Response
     */
    401: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetInteractionError = GetInteractionErrors[keyof GetInteractionErrors];

export type GetInteractionResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        agentId: string;
        request: OpenAiChatCompletionRequest;
        response: OpenAiChatCompletionResponse;
        type: 'openai:chatCompletions';
        createdAt: string;
    } | {
        id: string;
        agentId: string;
        request: GeminiGenerateContentRequest;
        response: GeminiGenerateContentResponse;
        type: 'gemini:generateContent';
        createdAt: string;
    } | {
        id: string;
        agentId: string;
        request: AnthropicMessagesRequest;
        response: AnthropicMessagesResponse;
        type: 'anthropic:messages';
        createdAt: string;
    };
};

export type GetInteractionResponse = GetInteractionResponses[keyof GetInteractionResponses];

export type GetInternalMcpCatalogData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/internal_mcp_catalog';
};

export type GetInternalMcpCatalogErrors = {
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetInternalMcpCatalogError = GetInternalMcpCatalogErrors[keyof GetInternalMcpCatalogErrors];

export type GetInternalMcpCatalogResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        name: string;
        version: string | null;
        description: string | null;
        repository: string | null;
        installationCommand: string | null;
        requiresAuth: boolean;
        authDescription: string | null;
        authFields: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        createdAt: string;
        updatedAt: string;
    }>;
};

export type GetInternalMcpCatalogResponse = GetInternalMcpCatalogResponses[keyof GetInternalMcpCatalogResponses];

export type CreateInternalMcpCatalogItemData = {
    body: {
        name: string;
        version?: string | null;
        description?: string | null;
        repository?: string | null;
        installationCommand?: string | null;
        requiresAuth?: boolean;
        authDescription?: string | null;
        authFields?: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
    };
    path?: never;
    query?: never;
    url: '/api/internal_mcp_catalog';
};

export type CreateInternalMcpCatalogItemErrors = {
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type CreateInternalMcpCatalogItemError = CreateInternalMcpCatalogItemErrors[keyof CreateInternalMcpCatalogItemErrors];

export type CreateInternalMcpCatalogItemResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        version: string | null;
        description: string | null;
        repository: string | null;
        installationCommand: string | null;
        requiresAuth: boolean;
        authDescription: string | null;
        authFields: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type CreateInternalMcpCatalogItemResponse = CreateInternalMcpCatalogItemResponses[keyof CreateInternalMcpCatalogItemResponses];

export type DeleteInternalMcpCatalogItemData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/internal_mcp_catalog/{id}';
};

export type DeleteInternalMcpCatalogItemErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type DeleteInternalMcpCatalogItemError = DeleteInternalMcpCatalogItemErrors[keyof DeleteInternalMcpCatalogItemErrors];

export type DeleteInternalMcpCatalogItemResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteInternalMcpCatalogItemResponse = DeleteInternalMcpCatalogItemResponses[keyof DeleteInternalMcpCatalogItemResponses];

export type GetInternalMcpCatalogItemData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/internal_mcp_catalog/{id}';
};

export type GetInternalMcpCatalogItemErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetInternalMcpCatalogItemError = GetInternalMcpCatalogItemErrors[keyof GetInternalMcpCatalogItemErrors];

export type GetInternalMcpCatalogItemResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        version: string | null;
        description: string | null;
        repository: string | null;
        installationCommand: string | null;
        requiresAuth: boolean;
        authDescription: string | null;
        authFields: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type GetInternalMcpCatalogItemResponse = GetInternalMcpCatalogItemResponses[keyof GetInternalMcpCatalogItemResponses];

export type UpdateInternalMcpCatalogItemData = {
    body?: {
        name?: string;
        version?: string | null;
        description?: string | null;
        repository?: string | null;
        installationCommand?: string | null;
        requiresAuth?: boolean;
        authDescription?: string | null;
        authFields?: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/internal_mcp_catalog/{id}';
};

export type UpdateInternalMcpCatalogItemErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type UpdateInternalMcpCatalogItemError = UpdateInternalMcpCatalogItemErrors[keyof UpdateInternalMcpCatalogItemErrors];

export type UpdateInternalMcpCatalogItemResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        version: string | null;
        description: string | null;
        repository: string | null;
        installationCommand: string | null;
        requiresAuth: boolean;
        authDescription: string | null;
        authFields: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type UpdateInternalMcpCatalogItemResponse = UpdateInternalMcpCatalogItemResponses[keyof UpdateInternalMcpCatalogItemResponses];

export type GetV1McpData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/mcp';
};

export type GetV1McpErrors = {
    /**
     * Default Response
     */
    401: {
        error: string;
        message: string;
    };
};

export type GetV1McpError = GetV1McpErrors[keyof GetV1McpErrors];

export type GetV1McpResponses = {
    /**
     * Default Response
     */
    200: {
        name: string;
        version: string;
        agentId: string;
        transport: string;
        capabilities: {
            tools: boolean;
        };
    };
};

export type GetV1McpResponse = GetV1McpResponses[keyof GetV1McpResponses];

export type PostV1McpData = {
    body?: {
        [key: string]: unknown;
    };
    path?: never;
    query?: never;
    url: '/v1/mcp';
};

export type PostV1McpResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type GetMcpServersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/mcp_server';
};

export type GetMcpServersErrors = {
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetMcpServersError = GetMcpServersErrors[keyof GetMcpServersErrors];

export type GetMcpServersResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        name: string;
        catalogId: string | null;
        metadata: {
            [key: string]: unknown;
        };
        createdAt: string;
        updatedAt: string;
    }>;
};

export type GetMcpServersResponse = GetMcpServersResponses[keyof GetMcpServersResponses];

export type InstallMcpServerData = {
    body: {
        name: string;
        catalogId?: string | null;
        metadata?: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown>;
        agentIds?: Array<string>;
    };
    path?: never;
    query?: never;
    url: '/api/mcp_server';
};

export type InstallMcpServerErrors = {
    /**
     * Default Response
     */
    400: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type InstallMcpServerError = InstallMcpServerErrors[keyof InstallMcpServerErrors];

export type InstallMcpServerResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        catalogId: string | null;
        metadata: {
            [key: string]: unknown;
        };
        createdAt: string;
        updatedAt: string;
    };
};

export type InstallMcpServerResponse = InstallMcpServerResponses[keyof InstallMcpServerResponses];

export type DeleteMcpServerData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/mcp_server/{id}';
};

export type DeleteMcpServerErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type DeleteMcpServerError = DeleteMcpServerErrors[keyof DeleteMcpServerErrors];

export type DeleteMcpServerResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteMcpServerResponse = DeleteMcpServerResponses[keyof DeleteMcpServerResponses];

export type GetMcpServerData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/mcp_server/{id}';
};

export type GetMcpServerErrors = {
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetMcpServerError = GetMcpServerErrors[keyof GetMcpServerErrors];

export type GetMcpServerResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        catalogId: string | null;
        metadata: {
            [key: string]: unknown;
        };
        createdAt: string;
        updatedAt: string;
    };
};

export type GetMcpServerResponse = GetMcpServerResponses[keyof GetMcpServerResponses];

export type DeleteV1OpenaiData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/openai/';
};

export type DeleteV1OpenaiResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type GetV1OpenaiData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/openai/';
};

export type GetV1OpenaiResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type HeadV1OpenaiData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/openai/';
};

export type HeadV1OpenaiResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type OptionsV1OpenaiData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/openai/';
};

export type OptionsV1OpenaiResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PatchV1OpenaiData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/openai/';
};

export type PatchV1OpenaiResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PostV1OpenaiData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/openai/';
};

export type PostV1OpenaiResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PutV1OpenaiData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/openai/';
};

export type PutV1OpenaiResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type DeleteV1OpenaiBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/openai/{*}';
};

export type DeleteV1OpenaiBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type GetV1OpenaiBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/openai/{*}';
};

export type GetV1OpenaiBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type HeadV1OpenaiBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/openai/{*}';
};

export type HeadV1OpenaiBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type OptionsV1OpenaiBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/openai/{*}';
};

export type OptionsV1OpenaiBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PatchV1OpenaiBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/openai/{*}';
};

export type PatchV1OpenaiBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PostV1OpenaiBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/openai/{*}';
};

export type PostV1OpenaiBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PutV1OpenaiBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/v1/openai/{*}';
};

export type PutV1OpenaiBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type DeleteV1OpenaiByAgentIdData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/openai/{agentId}/';
};

export type DeleteV1OpenaiByAgentIdResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type GetV1OpenaiByAgentIdData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/openai/{agentId}/';
};

export type GetV1OpenaiByAgentIdResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type HeadV1OpenaiByAgentIdData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/openai/{agentId}/';
};

export type HeadV1OpenaiByAgentIdResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type OptionsV1OpenaiByAgentIdData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/openai/{agentId}/';
};

export type OptionsV1OpenaiByAgentIdResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PatchV1OpenaiByAgentIdData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/openai/{agentId}/';
};

export type PatchV1OpenaiByAgentIdResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PostV1OpenaiByAgentIdData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/openai/{agentId}/';
};

export type PostV1OpenaiByAgentIdResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PutV1OpenaiByAgentIdData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/openai/{agentId}/';
};

export type PutV1OpenaiByAgentIdResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type DeleteV1OpenaiByAgentIdBy__Data = {
    body?: never;
    path: {
        agentId: string;
        '*': string;
    };
    query?: never;
    url: '/v1/openai/{agentId}/{*}';
};

export type DeleteV1OpenaiByAgentIdBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type GetV1OpenaiByAgentIdBy__Data = {
    body?: never;
    path: {
        agentId: string;
        '*': string;
    };
    query?: never;
    url: '/v1/openai/{agentId}/{*}';
};

export type GetV1OpenaiByAgentIdBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type HeadV1OpenaiByAgentIdBy__Data = {
    body?: never;
    path: {
        agentId: string;
        '*': string;
    };
    query?: never;
    url: '/v1/openai/{agentId}/{*}';
};

export type HeadV1OpenaiByAgentIdBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type OptionsV1OpenaiByAgentIdBy__Data = {
    body?: never;
    path: {
        agentId: string;
        '*': string;
    };
    query?: never;
    url: '/v1/openai/{agentId}/{*}';
};

export type OptionsV1OpenaiByAgentIdBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PatchV1OpenaiByAgentIdBy__Data = {
    body?: never;
    path: {
        agentId: string;
        '*': string;
    };
    query?: never;
    url: '/v1/openai/{agentId}/{*}';
};

export type PatchV1OpenaiByAgentIdBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PostV1OpenaiByAgentIdBy__Data = {
    body?: never;
    path: {
        agentId: string;
        '*': string;
    };
    query?: never;
    url: '/v1/openai/{agentId}/{*}';
};

export type PostV1OpenaiByAgentIdBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PutV1OpenaiByAgentIdBy__Data = {
    body?: never;
    path: {
        agentId: string;
        '*': string;
    };
    query?: never;
    url: '/v1/openai/{agentId}/{*}';
};

export type PutV1OpenaiByAgentIdBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type OpenAiChatCompletionsWithDefaultAgentData = {
    body?: OpenAiChatCompletionRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Bearer token for OpenAI
         */
        authorization: string;
    };
    path?: never;
    query?: never;
    url: '/v1/openai/chat/completions';
};

export type OpenAiChatCompletionsWithDefaultAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    403: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type OpenAiChatCompletionsWithDefaultAgentError = OpenAiChatCompletionsWithDefaultAgentErrors[keyof OpenAiChatCompletionsWithDefaultAgentErrors];

export type OpenAiChatCompletionsWithDefaultAgentResponses = {
    /**
     * Default Response
     */
    200: OpenAiChatCompletionResponse;
};

export type OpenAiChatCompletionsWithDefaultAgentResponse = OpenAiChatCompletionsWithDefaultAgentResponses[keyof OpenAiChatCompletionsWithDefaultAgentResponses];

export type OpenAiChatCompletionsWithAgentData = {
    body?: OpenAiChatCompletionRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Bearer token for OpenAI
         */
        authorization: string;
    };
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/openai/{agentId}/chat/completions';
};

export type OpenAiChatCompletionsWithAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    403: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    404: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type OpenAiChatCompletionsWithAgentError = OpenAiChatCompletionsWithAgentErrors[keyof OpenAiChatCompletionsWithAgentErrors];

export type OpenAiChatCompletionsWithAgentResponses = {
    /**
     * Default Response
     */
    200: OpenAiChatCompletionResponse;
};

export type OpenAiChatCompletionsWithAgentResponse = OpenAiChatCompletionsWithAgentResponses[keyof OpenAiChatCompletionsWithAgentResponses];

export type GetToolsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/tools';
};

export type GetToolsErrors = {
    /**
     * Default Response
     */
    401: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetToolsError = GetToolsErrors[keyof GetToolsErrors];

export type GetToolsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        name: string;
        /**
         *
         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
         *
         * The parameters the functions accepts, described as a JSON Schema object. See the
         * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
         * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
         * documentation about the format.
         *
         * Omitting parameters defines a function with an empty parameter list.
         *
         */
        parameters?: {
            [key: string]: unknown;
        };
        description: string | null;
        createdAt: string;
        updatedAt: string;
        agent: {
            id: string;
            name: string;
        } | null;
        mcpServer: {
            id: string;
            name: string;
        } | null;
    }>;
};

export type GetToolsResponse = GetToolsResponses[keyof GetToolsResponses];

export type GetUnassignedToolsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/tools/unassigned';
};

export type GetUnassignedToolsErrors = {
    /**
     * Default Response
     */
    401: {
        error: string | {
            message: string;
            type: string;
        };
    };
    /**
     * Default Response
     */
    500: {
        error: string | {
            message: string;
            type: string;
        };
    };
};

export type GetUnassignedToolsError = GetUnassignedToolsErrors[keyof GetUnassignedToolsErrors];

export type GetUnassignedToolsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        name: string;
        /**
         *
         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
         *
         * The parameters the functions accepts, described as a JSON Schema object. See the
         * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
         * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
         * documentation about the format.
         *
         * Omitting parameters defines a function with an empty parameter list.
         *
         */
        parameters?: {
            [key: string]: unknown;
        };
        description: string | null;
        createdAt: string;
        updatedAt: string;
        agent: {
            id: string;
            name: string;
        } | null;
        mcpServer: {
            id: string;
            name: string;
        } | null;
    }>;
};

export type GetUnassignedToolsResponse = GetUnassignedToolsResponses[keyof GetUnassignedToolsResponses];
